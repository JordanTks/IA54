/** 
 * 
 */
package fr.utbm.ia54.Agent

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Lifecycle
import fr.utbm.ia54.Event.GameSet 
import io.sarl.core.Schedules
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.InnerContextAccess
import fr.utbm.ia54.Event.Assault
import fr.utbm.ia54.Event.FrameSet
import fr.utbm.ia54.Event.FrameSatisfied
import fr.utbm.ia54.Event.TokenReceived
import java.util.UUID
import fr.utbm.ia54.Class.CoordPair
import fr.utbm.ia54.Event.PathCalculation
import fr.utbm.ia54.Event.PathFound
import io.sarl.util.Scopes
import fr.utbm.ia54.Event.AskNeighbourSatisfaction
import java.util.HashMap
import java.util.LinkedHashMap
import fr.utbm.ia54.Event.ResponseNeighbourSatisfaction
import fr.utbm.ia54.Event.FindPathWithAstarAlgo
import io.sarl.core.Behaviors
import fr.utbm.ia54.Event.SafetyWait

/** 
 * @author Jordan
 * 
 */
agent FrameAgent {
	uses Logging, Lifecycle, Schedules, InnerContextAccess, DefaultContextInteractions, Behaviors

	// PathCalculation
	val TIMEOUT = 50
	var previousPathCalculationId : long
	var previousPathCalculationJumpValue : int

	// FrameAgent state
	var isSatisfied = false
	var isBlocked = false // the tile which with it is paired will never move
	
	// FrameAgent knowledge
	var nbNeighbours : int
	var northNeighbour : UUID
	var eastNeighbour : UUID
	var southNeighbour : UUID
	var westNeighbour : UUID

	var hostedTile : UUID
	var hostedNumTile : int
	
	// Temporary knowledge
	var neighbourSatisfaction = new LinkedHashMap<Position, Boolean>()
	
	var ready = false
	var dimension = -1

	var idNum = -1
  	var idNumFromZero : int
  
	var xRow = -1
	var yCol = -1
	var coordPair : CoordPair // coords (Xrow,Ycol) of the frame
	var costG = 0 // from beginning to current
	var costH = 0 // from current to arrival
	var costF = 0 // sum of the previous (memorize)
	var uuidPreviousFrame : UUID
	var coordsXYPreviousFrame : CoordPair

	on Initialize { 
		
		idNum = occurrence.parameters.get(0) as Integer
		//idNumFromZero = idNum - 1

		xRow = occurrence.parameters.get(1) as Integer
		yCol = occurrence.parameters.get(2) as Integer
		coordPair = new CoordPair(xRow,yCol)
		
		nbNeighbours = 0
		northNeighbour = null
		eastNeighbour = null
		southNeighbour = null
		westNeighbour = null

		loggingName = 'FrameAgent' + idNum

		in (1000) [wake(new SafetyWait())]
		//emit(new FrameSet(this))
		
		// info("DEBUGG : Agent is set up.")
	}
	
	// Attempt at avoiding null pointer exceptions
	on SafetyWait {
		emit(new FrameSet(this))
	}
	
	// AK : PathCalculation by spreading message
	on PathCalculation {
		
		// Discard message if timeout
		if (System.currentTimeMillis - TIMEOUT > occurrence.timeStamp)
			return;
		
		// Check already forwarded path calculations to avoid spreading useless events
		// This implementation does NOT work if there are multiple different path calculations at once
		// -> The following would have to be modified
		
		// If the previous request was for the same path calculation ...
		if (previousPathCalculationId === occurrence.requestId)
			// ... and the previous request had the same or lower jump value ...
			if (previousPathCalculationJumpValue <= occurrence.jumpCount)
				// ... it is useless to spread the message
				return;

		// Setting the values for the next PathCalculation received
		previousPathCalculationId = occurrence.requestId
		previousPathCalculationJumpValue = occurrence.jumpCount
		
		// TODO : add boolean forcePath and if forcePath = false, drop event if (isSatisfied)
		
		// Adding itself to the path
		occurrence.path.add(this)
		
		// If we host the blank tile ...
		if (hostedNumTile == -1) // TODO : MAYBE THIS IS NOT SET THIS WAY RIGHT NOW
		{
			// ... we send the path that was found
			emit(new PathFound(occurrence.requestId, occurrence.jumpCount, occurrence.path),
				Scopes.addresses(defaultSpace.getAddress(occurrence.requestOrigin)))
			// We avoid spreading more useless PathCalculation
			return
		}

		// If we do not host the blank tile, we send the event PathCalculation to our neighbours ...
		// ... north one
		if (northNeighbour !== null && occurrence.provenanceDirection !== 2)
			emit(new PathCalculation(occurrence.requestId, occurrence.requestOrigin, 0,
					occurrence.timeStamp, occurrence.jumpCount + 1, occurrence.path))
		// ... east one
		if (eastNeighbour !== null && occurrence.provenanceDirection !== 3)
			emit(new PathCalculation(occurrence.requestId, occurrence.requestOrigin, 1,
				occurrence.timeStamp, occurrence.jumpCount + 1, occurrence.path))
		// ... south one
		if (southNeighbour !== null && occurrence.provenanceDirection !== 0)
			emit(new PathCalculation(occurrence.requestId, occurrence.requestOrigin, 2,
				occurrence.timeStamp, occurrence.jumpCount + 1, occurrence.path))
		// ... west one
		if (westNeighbour !== null && occurrence.provenanceDirection !== 1)
			emit(new PathCalculation(occurrence.requestId, occurrence.requestOrigin, 3,
				occurrence.timeStamp, occurrence.jumpCount + 1, occurrence.path))
		
	}
	
	// Forwards the question to the neighbours
	on AskNeighbourSatisfaction [!isAsked] {

		//info("DEBUGG : AskNeighbourSatisfaction !isAsked")
 
		// Clearing answers map
		neighbourSatisfaction.clear

		// Asking satisfaction of the two neighbour frames
		if (occurrence.north)
			emit(new AskNeighbourSatisfaction(true, Position.NORTH), Scopes.identifiers(northNeighbour))
		else
			emit(new AskNeighbourSatisfaction(true, Position.SOUTH), Scopes.identifiers(southNeighbour))

		if (occurrence.west)
			emit(new AskNeighbourSatisfaction(true, Position.WEST), Scopes.identifiers(westNeighbour))
		else
			emit(new AskNeighbourSatisfaction(true, Position.EAST), Scopes.identifiers(eastNeighbour))
	}

	// Get asked and have to answer back
	on AskNeighbourSatisfaction [isAsked] {

		//info("DEBUGG : AskNeighbourSatisfaction isAsked")
		
		// Answers back to the event transmitter
		emit(new ResponseNeighbourSatisfaction(isSatisfied, occurrence.direction), Scopes.identifiers(occurrence.source.UUID))
	}
	
	// Receive a response from a neighbour
	on ResponseNeighbourSatisfaction {

		//info("DEBUGG : ResponseNeighbourSatisfaction [frame] : direction " + occurrence.direction + "    isSatisfied" + occurrence.isSatisfied)

		// Store answer in map
		neighbourSatisfaction.put(occurrence.direction, occurrence.isSatisfied)

		// We check how much data we collected
		if (neighbourSatisfaction.size >= 2)
			// We have two answers, therefore we can send back the results to the tile
			emit(new ResponseNeighbourSatisfaction(neighbourSatisfaction), Scopes.identifiers(hostedTile))
	}
	
	def getXRow : int{
		return this.xRow
	}

	def getYCol : int {
		return this.yCol
	}

	def getCoordPair : CoordPair {
		return this.coordPair
	}
	
	def getIsSatisfied : boolean{
		return this.isSatisfied
	}

	def setIsSatisfied(b : boolean) {
		this.isSatisfied = b
	}

	def getIsBlocked : boolean {
		return this.isBlocked
	}

	def setIsBlocked(b : boolean) {
		this.isBlocked = b
	}

 	def getCostG() : int{
		return costG;
	}
	
	def setCostG(costG : int) {
			this.costG = costG;
	}

	def getCostH() : int{
			return costH;
	}

	def setCostH(costH : int) {
			this.costH = costH;
	}

	def getCostF() : int {
			return costF;
	}

	def setCostF(costF : int) {
			this.costF = costF;
	}

	def getUuidPreviousFrame() : UUID {
			return uuidPreviousFrame;
	}

	def setUuidPreviousFrame(uuidPreviousFrame : UUID) {
			this.uuidPreviousFrame = uuidPreviousFrame;
	}
 
	def getCoordsXYPreviousFrame() : CoordPair {
			return coordsXYPreviousFrame;
	}

	def setCoordsXYPreviousFrame(coordsXYPreviousFrame : CoordPair) {
			this.coordsXYPreviousFrame = coordsXYPreviousFrame;
	}
	
	def getCostsGHF : String{
		return "costG="+this.costG+" /costH="+this.costH+" /costF="+this.costF
	}
	
	def getIdNum : int {
		return this.idNum
	}
	
	// The assault must be forwarded to the right frame
	on Assault [!isAttacked] {
		
		// info("DEBUGG : I FORWARD ASSAULT !")
		
		if (occurrence.direction === Position.NORTH)
			emit(new Assault(Position.SOUTH, true), Scopes.identifiers(northNeighbour))
		else if (occurrence.direction === Position.SOUTH)
			emit(new Assault(Position.NORTH, true), Scopes.identifiers(southNeighbour))
		else if (occurrence.direction === Position.WEST)
			emit(new Assault(Position.EAST, true), Scopes.identifiers(westNeighbour))
		else if (occurrence.direction === Position.EAST)
			emit(new Assault(Position.WEST, true), Scopes.identifiers(eastNeighbour))
	}

	// The frame is being assaulted
	on Assault [isAttacked] {
 
		info(
			"=========================================== DEBUGG : I GOT ATTACKED ! emit FINDPATH! /hostedNumTile=" +hostedNumTile)
		
		// I have to run away by finding a path between me and the empty tile
		emit(new FindPathWithAstarAlgo(ID))
		// ... 
		
	}
	
	def getNumFrame : int {
		this.idNum
	}
	
	def setNorthNeighbour(id : UUID) {
		northNeighbour = id
		nbNeighbours++
	}

	def setEastNeighbour(id : UUID) {
		eastNeighbour = id
		nbNeighbours++
	}

	def setSouthNeighbour(id : UUID) {
		southNeighbour = id
		nbNeighbours++
	}

	def setWestNeighbour(id : UUID) {
		westNeighbour = id
		nbNeighbours++
	}

	def getNbNeighbours : int{
		return this.nbNeighbours
	}

	def getNorthNeighbour : UUID {
		return this.northNeighbour
	}
	
	def getEastNeighbour : UUID {
		return this.eastNeighbour
	}
	
	def getSouthNeighbour : UUID {
		return this.southNeighbour
	}
	
	def getWestNeighbour : UUID {
			return this.westNeighbour
	}

	def setHostedTile(id : UUID) { 
		hostedTile = id
	}
	
	def getHostedTile : UUID {
		return this.hostedTile
	}

	def setHostedNumTile(num : int) {
		hostedNumTile = num
	}

	def getHostedNumTile : int {
		return this.hostedNumTile
	}
	
	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
	}
 
	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}
	
}
