
package fr.utbm.ia54.Agent

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Lifecycle
import fr.utbm.ia54.Event.GameSet
import fr.utbm.ia54.Event.FrameSatisfied
import io.sarl.core.DefaultContextInteractions
import java.util.ArrayList
import java.util.List
import java.util.Collections
import fr.utbm.ia54.Event.FrameSet
import fr.utbm.ia54.Event.GameCompleted
import fr.utbm.ia54.Event.TileSet
import fr.utbm.ia54.Event.TokenReceived
import io.sarl.util.Scopes
import fr.utbm.ia54.Event.TokenReleased
import io.sarl.core.Behaviors
import fr.utbm.ia54.gui.TaquinFxViewerController
import fr.utbm.taquin.events.ActionUI
import java.util.UUID
import fr.utbm.ia54.Class.CoordPair
import fr.utbm.ia54.Class.InfosFrame

enum position {
	NORTH,
	SOUTH,
	EAST,
	WEST
	;
}
 
agent BoardGameAgent {
	uses Logging, Lifecycle, DefaultContextInteractions, Behaviors
	
	var PROBLEM_SIZE = 3
	var nbFrameSet = 0
	var nbTileSet = 0
	var frameList = new ArrayList<FrameAgent>()
	
	// TKS
	var frameUUIDList = new ArrayList<UUID>()
	var listCoordPairsOfFrames = new ArrayList<CoordPair>()
	
	var openListOfFrames = new ArrayList<InfosFrame>()
	var closedListOfFrames = new ArrayList<InfosFrame>()
	
	// use the Class InfosFrame instead of these var
//	var listOfCostG = new ArrayList<Integer>() // from beginning to current
//	var listOfCostH = new ArrayList<Integer>() // from current to arrival
//	var listOfCostF = new ArrayList<Integer>() // sum of the previous (memorize)
	
	var tileList = new ArrayList<TileAgent>()
	var tokenPriorityList = new ArrayList<ArrayList<TileAgent>>()

	var ctrl : TaquinFxViewerController

	
	on Initialize {

		loggingName = 'BoardGameAgent'

		PROBLEM_SIZE = occurrence.parameters.get(0) as Integer
		ctrl = occurrence.parameters.get(1) as TaquinFxViewerController

		val numFrameList : List<Integer> = new ArrayList // TKS: redondance de nom --> changement

		for (var i = 1; i <= Math.pow(PROBLEM_SIZE, 2); i++)
			numFrameList.add(i) // TKS

		for (var i = 0; i <= Math.pow(PROBLEM_SIZE, 2) - 1; i++) { // spawn FrameAgent(num,row,col,size)
		 	// TKS
			frameUUIDList.add(spawn(FrameAgent, #[numFrameList.get(i), i / PROBLEM_SIZE, i % PROBLEM_SIZE, PROBLEM_SIZE])) // get UUID of the frameAgent
			listCoordPairsOfFrames.add(new CoordPair((i / PROBLEM_SIZE), (i % PROBLEM_SIZE)))
			
			/*listOfCostG.add(-1)
			listOfCostH.add(-1)
			listOfCostF.add(-1)*/
		}
		
		info("Board game has been set.")
	}
 
	on FrameSet {
		
		nbFrameSet++

		frameList.add(occurrence.frame)

		// ouais c'est bon on est tous là !
		if (nbFrameSet === Math.round(Math.pow(PROBLEM_SIZE, 2)))
		{
			info("Every single FrameAgent is set. Spawning every single TileAgent.")

			// Ordering initial list of frame in order to set neighbours
			Collections.sort(frameList)[a, b|a.numFrame - b.numFrame]
			
			// Setting neighbours
			var c = 0
			for (f : frameList)
			{
				if (c % PROBLEM_SIZE != 0) // when true, the frame does have a west neighbour
					f.setWestNeighbour(frameList.get(c - 1).ID)

				if (c / PROBLEM_SIZE != 0) // when true, the frame does have a north neighbour
					f.setNorthNeighbour(frameList.get(c - PROBLEM_SIZE).ID)

				if (c + PROBLEM_SIZE < (PROBLEM_SIZE * PROBLEM_SIZE)) // when true, the frame does have a south neighbour
					f.setSouthNeighbour(frameList.get(c + PROBLEM_SIZE).ID)

				if (c % PROBLEM_SIZE != (PROBLEM_SIZE - 1)) // when true, the frame does have a east neighbour
					f.setEastNeighbour(frameList.get(c + 1).ID)
				
				c++
			}
			
			// Shuffle tile positions
			var startingTiles : List<Integer> = new ArrayList
			
			for (var i = 1; i < Math.pow(PROBLEM_SIZE, 2); i++)
				startingTiles.add(i)

			Collections.shuffle(startingTiles)

			info("Starting positions " + startingTiles)

			// COMMUNICATION AVEC UI
			// emit(new InitDone(startingTiles))
			ctrl.monTest(startingTiles);
			
			// Spawn tile agents (num tile/UUID frame/num frame/ problem size)
			for (var i = 0; i < Math.pow(PROBLEM_SIZE, 2) - 1; i++)
				spawn(TileAgent, #[startingTiles.get(i), frameList.get(i).ID, i, PROBLEM_SIZE])
			
			// Spawn blank tile
			spawn(EmptyTileAgent)			
		}
	}
	
	on TileSet {
		
		nbTileSet++
		
		if (occurrence.tile !== null) // DO NOT REMOVE THIS TEST
			tileList.add(occurrence.tile)

		if (nbTileSet === Math.round(Math.pow(PROBLEM_SIZE, 2))) {
			info("Every single TileAgent is set. Setting token priority lists.")

			// Ordering initial list by numTile to avoid later more complicated computation
			Collections.sort(tileList)[a, b|a.numTile - b.numTile]
					
			var tempList = new ArrayList<TileAgent>()
							
			// Setting token priority lists
			for (var i = 1; i < PROBLEM_SIZE; i++)
				tokenPriorityList.add(new ArrayList())
			
			// Put the tile in the right tokenPriority list
			for (t : tileList)
				tokenPriorityList.get(t.getTokenPriority).add(t)

			// Modify the sorting of each list
			for (l : tokenPriorityList)		
			{
				for (var tilesToSwitch = (l.size / 2) + 1; tilesToSwitch > 0 ; tilesToSwitch--)
				{
					tempList.add(l.get(0))
					l.remove(0)
				}
				
				while (!tempList.empty)
				{
					l.add(0, tempList.get(0))
					tempList.remove(0)
				}
				
				//for (t : l)
				//	info(t.numTile)
			}

			info("TokenPriorityList data set up.")
			
			// Sending the token
			wake(new TokenReleased)
		}
	}

	on TokenReleased {
		
		// Looking for the first unsatisfied tile on the first priority list
		do {
			for (t : tokenPriorityList.get(0))
			{
				if (!t.isHappy)
				{
					emit(new TokenReceived(), Scopes.addresses(defaultSpace.getAddress(t.ID)))
					return
				}
			}
			
			tokenPriorityList.remove(0)
			
			// It is over
			if (tokenPriorityList.empty)
				return
			// Else ... get to the next list by looping
			
		} while (!tokenPriorityList.empty)
	}

	on ActionUI {
		info("JE VAIS FAIRE CHANGER COULEUR.")
		ctrl.setColor("rouge", occurrence.target)
	}
	
	/** 
	 * calculate the euclidean distance between 2 frames
	 * @params a,b : 2 FrameAgent
	 * @return int: euclidean distance
	 */
	 // TKS
	def distEuclidian(a : FrameAgent, b : FrameAgent) : int {
		return ((a.XRow - b.XRow) * (a.XRow - b.XRow) + (a.YCol - b.YCol) * (a.YCol - b.YCol))
	}
	
	/** 
	 * determinate if the frame is in the list
	 * @params pair, listOfFrames : CoordPair & ArrayList<InfosFrame>
	 * @return boolean: true if the CoordPair correspond to coords of an FrameAgent in the list
	 */
	 // TKS
	def isInFrameList(pair : CoordPair, listOfFrames : ArrayList<InfosFrame>) : boolean {
		for (fa : listOfFrames) {
			 if(pair.equals(fa.coordsCurrentFrame))
			 	return true
		}
		return false
	}
	/** 
	 * add the neighbour frames of the current frame
	 * @params currentFrame: the current FrameAgent
	 */
	 // TKS
	def addNeighbourFrames(currentFrame : FrameAgent){
				
		// the north's frame exists======================================================================================================================
		if (currentFrame.northNeighbour != null) {
			var index = frameUUIDList.indexOf(currentFrame.northNeighbour)
			
			//TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
			if(!frameList.get(index).isSatisfied){
				
				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var newCoords = frameList.get(index).coordPair
												
				// if doesn't exist in the closed list
				if (isInFrameList(coordNeighbour, closedListOfFrames)) {
					
					// the treated frame (stock the infos)
					var infosFrame = new InfosFrame(currentFrame.northNeighbour, coordNeighbour)					
										
					// costG of north's neighbour: cost of previous + distance to previous
					var indexForClosedList = -1
					for (iterator : closedListOfFrames) {
						indexForClosedList++
						if(iterator.uuidCurrentFrame == currentFrame.ID)
							break
					}
					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG + distEuclidian(frameList.get(index), currentFrame)

					//TODO: ATTENTION ! DOIT ETRE LA FRAME POSSEDANT LA BLANKTILE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					var arrivalFrame = frameList.get(0)

					// costH of north's neighbour: it to arrival
					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
					infosFrame.costF = infosFrame.costG + infosFrame.costH
					
					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
					infosFrame.uuidPreviousFrame = currentFrame.ID
					infosFrame.coordsXYPreviousFrame = currentFrame.coordPair
					
					var indexForOpenList = -1
					for (iterator : openListOfFrames) {
						indexForOpenList++
						if (iterator.uuidCurrentFrame == currentFrame.northNeighbour)
							break
					}
						
					// if already exists: compare the cost
					if (isInFrameList(coordNeighbour, openListOfFrames)) {
											
						// only if the new path is shorter: update it ELSE do nothing
						if(infosFrame.costF < openListOfFrames.get(indexForOpenList).costF){
							openListOfFrames.set(indexForOpenList,infosFrame)
						}
					}
					// the treated frame (north's frame) is not in the openList yet: add it
					else{
						openListOfFrames.add(infosFrame)
					}
				}
			}
		}

		// TODO: the south's frame exists======================================================================================================================
		
		// TODO: the east's frame exists======================================================================================================================
			
		// TODO: the west's frame exists======================================================================================================================
	}
	
	/** 
	 * get the best cost from the frameList
	 * @param listFrames: list of InfosFrame
	 * @return InfosFrame: the infosFrame with the best (lower) cost
	 */
	 // TKS
	def getBestFrame(listFrames : ArrayList<InfosFrame>) : InfosFrame{
		var costF = listFrames.get(0).costF
		var infoFrame : InfosFrame 
		
		for(frame : listFrames)
			if(frame.costF < costF){ // get the lower cost in the list
				costF = frame.costF
				infoFrame = frame
			}
				
		return infoFrame		
	}
	
	/** 
	 * add the InfosFrame in the closedList and remove it from the openList
	 * @param coords: CoordPair of the frame to manipulate
	 */
	 // TKS
	def addInClosedList(coords : CoordPair){
		var index = -1
		for(ite : openListOfFrames){
			index++
			if(ite.coordsCurrentFrame == coords){ 
				closedListOfFrames.add(ite) 	// add in the closedList
				openListOfFrames.remove(index) // remove it from the openList
				break
			}
				
		}
	}
	
	// TKS
	// TODO: implement here the function "retrouver_chemin()"
	// TODO: determinate the frame (BeginningFrame) on wich the currentTile wants to go (FIRST aggression of the chain)
	// THEN 
	// TODO: implement the scheduling of the algorithm A*, for using it with the BeginningFrame (tileX who wants to move) and the ArrivalFrame(blankTile)

	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}
}
