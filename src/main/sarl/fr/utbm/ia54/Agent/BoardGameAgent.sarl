/** 
 * 
 */
package fr.utbm.ia54.Agent

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Lifecycle
import fr.utbm.ia54.Event.GameSet
import fr.utbm.ia54.Event.FrameSatisfied
import io.sarl.core.DefaultContextInteractions
import java.util.ArrayList
import java.util.List
import java.util.Collections
import fr.utbm.ia54.Event.FrameSet
import fr.utbm.ia54.Event.GameCompleted
import fr.utbm.ia54.Event.TileSet
import fr.utbm.ia54.Event.TokenReceived

/** 
 * @author Jordan
 * 
 */
agent BoardGameAgent {
	uses Logging, Lifecycle, DefaultContextInteractions
	
	val PROBLEM_SIZE = 3
	var nbFrameSet = 0
	var nbTileSet = 0
	
	//var nbFrameSatisfied = 0 // probablement inutile
	
	on Initialize {

		loggingName = 'BoardGameAgent'

		// TODO passer Ã  array en 2D probablement plus logique et plus simple pour les traitements futurs (idem dans on FrameSet)
		// Il faudra set les Frame pour qu'ils connaissent leurs voisins
		
		val frameList : List<Integer> = new ArrayList

		for (var i = 1; i <= Math.pow(PROBLEM_SIZE, 2); i++)
			frameList.add(i)

		for (var i = 0; i <= Math.pow(PROBLEM_SIZE, 2) - 1; i++) // spawn FrameAgent
			spawn(FrameAgent, #[frameList.get(i), i / PROBLEM_SIZE, i % PROBLEM_SIZE, PROBLEM_SIZE])
		
		info("Board game has been set.")
	}

	on FrameSet {
		
		nbFrameSet++

		if (nbFrameSet === Math.round(Math.pow(PROBLEM_SIZE, 2)))
		{
			info("Every single FrameAgent is set. Spawning every single TileAgent.")
			
			// On pourrait aussi wake sur un event a part et spawn les tileAgent dans un "on SettingTile" ou qqch du genre

			val startingTiles : List<Integer> = new ArrayList
			
			for (var i = 1; i < Math.pow(PROBLEM_SIZE, 2); i++)
				startingTiles.add(i)
				
			Collections.shuffle(startingTiles)

			info("Starting positions " + startingTiles)

			for (var i = 0; i < Math.pow(PROBLEM_SIZE, 2) - 1; i++) // spawn TileAgent
				spawn(TileAgent, #[startingTiles.get(i), i / PROBLEM_SIZE, i % PROBLEM_SIZE, PROBLEM_SIZE])

			spawn(EmptyTileAgent)
		}
	}
	
	on TileSet {
		
		nbTileSet++

		if (nbTileSet === Math.round(Math.pow(PROBLEM_SIZE, 2)) - 1) {
			info("Every single TileAgent is set. Sending a token.")
			
			emit(new TokenReceived) // Scope sur la tile n 1 a ajouter
		}
	}


	/* PROBABLEMENT DEJA OBSOLETE

	on FrameSatisfied {

		if (!occurrence.satisfied)
			nbFrameSatisfied--
		else
			if (nbFrameSatisfied === Math.round(Math.pow(PROBLEM_SIZE, 2)) - 1)
			{	
				info("Checking satisfaction of every Frame.") // in case of false positive due to synchronization issues
				// todo
				
				if (1 === 1)
				{
					info("Every Frame satisfied. Game completed.")
					emit(new GameCompleted)
				
				}
			}
	}*/

	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}
}
