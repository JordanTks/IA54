package fr.utbm.ia54.Agent

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Lifecycle
import fr.utbm.ia54.Event.GameSet
import fr.utbm.ia54.Event.FrameSatisfied
import io.sarl.core.DefaultContextInteractions
import java.util.ArrayList
import java.util.List
import java.util.Collections
import fr.utbm.ia54.Event.FrameSet
import fr.utbm.ia54.Event.GameCompleted
import fr.utbm.ia54.Event.TileSet
import fr.utbm.ia54.Event.TokenReceived
import io.sarl.util.Scopes
import fr.utbm.ia54.Event.TokenReleased
import io.sarl.core.Behaviors
import fr.utbm.ia54.gui.TaquinFxViewerController
import fr.utbm.taquin.events.ActionUI
import java.util.UUID
import fr.utbm.ia54.Class.CoordPair
import fr.utbm.ia54.Class.InfosFrame
import java.util.LinkedHashSet
import io.sarl.core.Schedules
import fr.utbm.ia54.Event.FindPathWithAstarAlgo

enum Position {
	NORTH,
	SOUTH,
	EAST,
	WEST
	;
}
 
agent BoardGameAgent {
	uses Logging, Lifecycle, DefaultContextInteractions, Behaviors, Schedules
	
	var PROBLEM_SIZE = 3
	var nbFrameSet = 0
	var nbTileSet = 0
	var frameList = new ArrayList<FrameAgent>()
	
	var frameUUIDList = new ArrayList<UUID>()
	var listCoordPairsOfFrames = new ArrayList<CoordPair>()
	
	var openListOfFrames = new ArrayList<InfosFrame>()
	var closedListOfFrames = new ArrayList<InfosFrame>()

	// infos of the frame on which there is the Tile with the Token
	var haveTokenFrame : FrameAgent
	var haveTokenInfosFrame : InfosFrame
	var uuidFRAMEwithTokenTile : UUID
	var coordsFRAMEwithTokenTile : CoordPair
	
	// infos of the frame on which there is the BlankTile
	var arrivalFrame : FrameAgent
	var arrivalInfosFrame : InfosFrame
	var uuidFRAMEwithBlankTile : UUID
	var coordsFRAMEwithBlankTile : CoordPair
	
	// infos of the frame on which there is the beginningFrame (launcher of the A-star algorithm)
	var beginningFrame : FrameAgent
	var beginningInfosFrame : InfosFrame
	var uuidFRAMEbeginning : UUID
	var coordsFRAMEbeginning : CoordPair
	
	var blankTile : EmptyTileAgent
	var tileList = new ArrayList<TileAgent>()
	var tokenPriorityList = new ArrayList<ArrayList<TileAgent>>()

	var ctrl : TaquinFxViewerController

	
	on Initialize {

		loggingName = 'BoardGameAgent'

		PROBLEM_SIZE = occurrence.parameters.get(0) as Integer
		ctrl = occurrence.parameters.get(1) as TaquinFxViewerController

		val numFrameList : List<Integer> = new ArrayList

		for (var i = 1; i <= Math.pow(PROBLEM_SIZE, 2); i++)
			numFrameList.add(i)

		for (var i = 0; i <= Math.pow(PROBLEM_SIZE, 2) - 1; i++) { // spawn FrameAgent(num,row,col,size)
			frameUUIDList.add(spawn(FrameAgent, #[numFrameList.get(i), i / PROBLEM_SIZE, i % PROBLEM_SIZE, PROBLEM_SIZE])) // get UUID of the frameAgent
			listCoordPairsOfFrames.add(new CoordPair((i / PROBLEM_SIZE), (i % PROBLEM_SIZE)))
		}
		
		info("Board game has been set.")		
	}
 
	on FrameSet {
		
		nbFrameSet++

		frameList.add(occurrence.frame)

		// ouais c'est bon on est tous lÃ  !
		if (nbFrameSet === Math.round(Math.pow(PROBLEM_SIZE, 2)))
		{
			info("Every single FrameAgent is set. Spawning every single TileAgent.")

			// Detects error that randomly happens
			for (f : frameList) {
				if (f === null) {
					info("ERROR 1 : ONE OF THE FRAME RETURNED NULL POINTER")
					return
				}

			}
			
			// Ordering initial list of frame in order to set neighbours
			Collections.sort(frameList)[a, b|a.numFrame - b.numFrame]
			
			// Setting neighbours
			var c = 0
			for (f : frameList)
			{
				if (c % PROBLEM_SIZE != 0) // when true, the frame does have a west neighbour
					f.setWestNeighbour(frameList.get(c - 1).ID)

				if (c / PROBLEM_SIZE != 0) // when true, the frame does have a north neighbour
					f.setNorthNeighbour(frameList.get(c - PROBLEM_SIZE).ID)

				if (c + PROBLEM_SIZE < (PROBLEM_SIZE * PROBLEM_SIZE)) // when true, the frame does have a south neighbour
					f.setSouthNeighbour(frameList.get(c + PROBLEM_SIZE).ID)

				if (c % PROBLEM_SIZE != (PROBLEM_SIZE - 1)) // when true, the frame does have a east neighbour
					f.setEastNeighbour(frameList.get(c + 1).ID)
				
				c++
			}
			
			// Shuffle tile positions
			var startingTiles : List<Integer> = new ArrayList
			
			for (var i = 1; i < Math.pow(PROBLEM_SIZE, 2); i++)
				startingTiles.add(i)

			Collections.shuffle(startingTiles)

			info("Starting positions " + startingTiles)

			// COMMUNICATION AVEC UI
			// emit(new InitDone(startingTiles))
			ctrl.monTest(startingTiles);
			
			// Spawn tile agents (num tile/UUID frame/num frame/ problem size)
			for (var i = 0; i < Math.pow(PROBLEM_SIZE, 2) - 1; i++)
			{
				var id = spawn(TileAgent, #[startingTiles.get(i), frameList.get(i).ID, i, PROBLEM_SIZE])
				frameList.get(i).hostedTile = id
				frameList.get(i).hostedNumTile = startingTiles.get(i)
				frameList.get(i).isSatisfied = (startingTiles.get(i) === frameList.get(i).numFrame)
			}
			
			// Spawn blank tile
			var id = spawn(EmptyTileAgent,#[frameList.get(PROBLEM_SIZE * PROBLEM_SIZE - 1).ID, PROBLEM_SIZE * PROBLEM_SIZE])
			frameList.get(PROBLEM_SIZE*PROBLEM_SIZE - 1).hostedTile = id
			
			uuidFRAMEwithBlankTile = frameList.get(PROBLEM_SIZE * PROBLEM_SIZE - 1).ID
			coordsFRAMEwithBlankTile = frameList.get(PROBLEM_SIZE * PROBLEM_SIZE - 1).coordPair
			arrivalInfosFrame = new InfosFrame(uuidFRAMEwithBlankTile, coordsFRAMEwithBlankTile)
			arrivalFrame = frameList.get(PROBLEM_SIZE * PROBLEM_SIZE - 1)
			arrivalFrame.hostedNumTile = 0
		}
	}
	
	on TileSet {
		
		nbTileSet++
		
		// TileAgent spawned
		if (occurrence.tile !== null) // DO NOT REMOVE THIS TEST
			tileList.add(occurrence.tile)
		// EmptyTileAgent (blankTile) spawned
		else
			blankTile = occurrence.blank

		if (nbTileSet === Math.round(Math.pow(PROBLEM_SIZE, 2))) {
			info("Every single TileAgent is set. Setting token priority lists.")

			// Detects error that randomly happens
			for (t : tileList)
			{
				if (t === null)
				{
					info("ERROR 2 : ONE OF THE TILE RETURNED NULL POINTER")
					return
				}

			}

			// Ordering initial list by numTile to avoid later more complicated computation
			Collections.sort(tileList)[a, b|a.numTile - b.numTile]
					
			var tempList = new ArrayList<TileAgent>()
							
			// Setting token priority lists
			for (var i = 1; i < PROBLEM_SIZE; i++)
				tokenPriorityList.add(new ArrayList())
			
			// Put the tile in the right tokenPriority list
			for (t : tileList)
				tokenPriorityList.get(t.getTokenPriority).add(t)

			// Modify the sorting of each list
			for (l : tokenPriorityList)		
			{
				for (var tilesToSwitch = (l.size / 2) + 1; tilesToSwitch > 0 ; tilesToSwitch--)
				{
					tempList.add(l.get(0))
					l.remove(0)
				}
				
				while (!tempList.empty)
				{
					l.add(0, tempList.get(0))
					tempList.remove(0)
				}
				
				//for (t : l)
				//	info(t.numTile)
			}

			info("TokenPriorityList data set up.")
			
			// Sending the token
			wake(new TokenReleased)

			// Wait until every agent is spawned - TODO: NOT PRECISE AT ALL : more delay if bigger size
//			info("- Begin A-star algorithm -")
//			
//			if(PROBLEM_SIZE<10)
//				in(500 * PROBLEM_SIZE)[findPath]
//			else
//				in(700 * PROBLEM_SIZE)[findPath]
		}
	}

	on TokenReleased {
		
		for (t : tokenPriorityList.get(0))
		{
			if (t.isHappy) {
				for(ite: frameList){
					if(t.uuidFrameHost === ite.ID){
						ite.isBlocked = true
						ctrl.setColor("purple", t.numTile)
						break
					}
				}
			}
			else
			{
				break
			}
		}
		
		// Looking for the first unsatisfied tile on the first priority list
		do {
			for (t : tokenPriorityList.get(0))
			{
				if (!t.isHappy)
				{
					emit(new TokenReceived(), Scopes.addresses(defaultSpace.getAddress(t.ID)))
					
					// set the infosFrame for the frame on which there is the Tile with the Token
					for(var i=0; i<frameList.size; i++){
						if(frameList.get(i).hostedTile === t.ID){
							uuidFRAMEwithTokenTile = frameList.get(i).ID
							coordsFRAMEwithTokenTile = frameList.get(i).coordPair
							haveTokenInfosFrame = new InfosFrame(uuidFRAMEwithTokenTile, coordsFRAMEwithTokenTile)
							haveTokenFrame = frameList.get(i)
							
							info("on TokenReleased: hostedNumTile=" + haveTokenFrame.hostedNumTile)
							break
						}
					}
					
					
					return
				}
			}
			
			tokenPriorityList.remove(0) 
			
			// It is over
			if (tokenPriorityList.empty)
				return
			// Else ... get to the next list by looping
			
		} while (!tokenPriorityList.empty)
	}

	on ActionUI {
		ctrl.setColor(occurrence.prop, occurrence.target)
	}
	
	// calculate the euclidean distance between 2 frames: return int: square euclidean distance
	def distEuclidian(a : FrameAgent, b : FrameAgent) : int {
		return ((a.XRow - b.XRow) * (a.XRow - b.XRow) + (a.YCol - b.YCol) * (a.YCol - b.YCol))
	}
	
	// determinate if the frame is in the list: return boolean: true if the CoordPair correspond to coords of an FrameAgent in the list
	def isInFrameList(pair : CoordPair, listOfFrames : ArrayList<InfosFrame>) : boolean {
		for (fa : listOfFrames) {
			 if(pair.equals(fa.coordsCurrentFrame))
			 	return true
		}
		return false
	}

	def addOneNeighbourFrame(currentFrame : FrameAgent, neighbour : UUID) {
		var index = frameUUIDList.indexOf(neighbour)

		// not satisfied AND not blocked AND not the FRAMEwithTokenTile
		if (//!frameList.get(index).isSatisfied && 
			!frameList.get(index).isBlocked &&
			(frameList.get(index).ID != uuidFRAMEwithTokenTile)) {

			var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var coordNeighbour = frameList.get(index).coordPair
			// if doesn't exist in the closed list
			if (!isInFrameList(coordNeighbour, closedListOfFrames)) {

				// the treated frame (stock the infos)
				var infosFrame = new InfosFrame(neighbour, coordNeighbour)

				// costG of neighbour: cost of previous + distance to previous
				var indexForClosedList = -1
				for (iterator : closedListOfFrames) {
					indexForClosedList++
					if (iterator.uuidCurrentFrame == currentFrame.ID)
						break
				}

				infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
					distEuclidian(frameList.get(index), currentFrame)

				// costH of neighbour: it to arrival
				infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
				infosFrame.costF = infosFrame.costG + infosFrame.costH

				// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
				infosFrame.uuidPreviousFrame = currentFrame.ID
				infosFrame.coordsPreviousFrame = currentFrame.coordPair

				var indexForOpenList = -1
				if (!openListOfFrames.empty) {
					for (iterator : openListOfFrames) {
						indexForOpenList++
						if (iterator.uuidCurrentFrame == neighbour)
							break
					}
				}
				// if(indexForOpenList > -1){
				
				// if already exists: compare the cost
				if (isInFrameList(coordNeighbour, openListOfFrames)) {
					// only if the new path is shorter: update it ELSE do nothing
					if ((indexForOpenList > -1) && (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF))
						openListOfFrames.set(indexForOpenList, infosFrame)

				} // the treated frame is not in the openList yet: add it
				else {
					openListOfFrames.add(infosFrame)
				}
				// }
			}
		}
	}
	
	//add the neighbour's frames of the current frame
	def addNeighbourFrames(currentFrame : FrameAgent) {
		if (currentFrame.southNeighbour != null) {
			info("frame" + currentFrame.idNum + ": SOUTH neighbour")
			addOneNeighbourFrame(currentFrame, currentFrame.southNeighbour)
		}
		if(currentFrame.northNeighbour != null){
			info("frame"+currentFrame.idNum+": NORTH neighbour")
			addOneNeighbourFrame(currentFrame, currentFrame.northNeighbour)
		}
		if (currentFrame.westNeighbour != null) {
			info("frame" + currentFrame.idNum + ": WEST neighbour")
			addOneNeighbourFrame(currentFrame, currentFrame.westNeighbour)
		}
		if (currentFrame.eastNeighbour != null) {
			info("frame" + currentFrame.idNum + ": EAST neighbour")
			addOneNeighbourFrame(currentFrame, currentFrame.eastNeighbour)
		}
	}
	
	// get the frame with best cost from the frameList
	def getBestFrame(listFrames : ArrayList<InfosFrame>) : InfosFrame {
		if(!listFrames.empty){ // the list is not empty
			var costF = listFrames.get(0).costF
			var infoFrame = listFrames.get(0)
			
			for(frame : listFrames){
				if(frame.costF < costF){ // get the lower cost in the list
					costF = frame.costF
					infoFrame = frame
				}
			}
			return infoFrame
		}
		
		return null		
	}
	
	//add the InfosFrame in the closedList and remove it from the openList
	def addInClosedList(coords : CoordPair){
		var index = -1
		for(ite : openListOfFrames){
			index++
			if(ite.coordsCurrentFrame.equals(coords)){ // found it in the openList
				closedListOfFrames.add(ite) 	// add in the closedList
				break
			}				
		}
		openListOfFrames.remove(index) // remove it from the openList
	}
	
	//get the chain of aggression in a list of InfosFrame: return ArrayList<InfosFrame>: the list of InfosFrame for the aggression in the right order
	def buildChainAggression(beginningFrame : InfosFrame) : ArrayList<InfosFrame> {
		var chain = new ArrayList<InfosFrame>
		var index = closedListOfFrames.size-1
		var tmpFrame : InfosFrame
		var prevFrame : InfosFrame
		var flagEnd = false
		
		// the last one is the arrivalFrame
		tmpFrame = closedListOfFrames.get(index)
		chain.add(tmpFrame)
		
		// get the previousFrame of the first one
		prevFrame = new InfosFrame(tmpFrame.uuidPreviousFrame,tmpFrame.coordsPreviousFrame)
				
		// loop with each previousFrame of the currentFrame treated
		while(!prevFrame.equals(beginningFrame)){		
			chain.add(prevFrame)
			
			var i = -1
			for(ite : closedListOfFrames){
				
				// the end
				if(tmpFrame.coordsPreviousFrame==null){ 
					flagEnd = true
					break	
				}
					
				i++
				if(ite.coordsCurrentFrame.equals(tmpFrame.coordsPreviousFrame))
					break
			}
			
			// looping on the closedList
			if(!flagEnd){
				tmpFrame = closedListOfFrames.get(i)
				prevFrame = new InfosFrame(closedListOfFrames.get(i).uuidCurrentFrame, closedListOfFrames.get(i).coordsCurrentFrame)
			}
			
			// the end of the loop
			else break
		}
		
		return chain
	}
	
	// Execute A* algorithm
	def findPath {
		var currentFrame = beginningInfosFrame
		openListOfFrames.add(beginningInfosFrame)
		addInClosedList(beginningInfosFrame.coordsCurrentFrame)
		
		// get the frame with the index of FrameList
		var indexOfFrameList = -1
		for(ite : frameList){
			indexOfFrameList++
			if (ite.coordPair.equals(beginningInfosFrame.coordsCurrentFrame))
				break
		}
		
		// add the neighbours in the openList
		addNeighbourFrames(frameList.get(indexOfFrameList))
		
		// until the destination has been reached && openList is empty
		while(!currentFrame.coordsCurrentFrame.equals(arrivalInfosFrame.coordsCurrentFrame) && !openListOfFrames.empty){
			currentFrame = getBestFrame(openListOfFrames)
			addInClosedList(currentFrame.coordsCurrentFrame)
			
			var indexOfFrameList2 = -1
			for(ite : frameList){
				indexOfFrameList2++
				if (ite.coordPair.equals(currentFrame.coordsCurrentFrame))
					break
			}	
			addNeighbourFrames(frameList.get(indexOfFrameList2))
		}
		
		// if destination is reached : build the path in the opposite direction of the chain of aggression
		if(currentFrame.coordsCurrentFrame.equals(arrivalInfosFrame.coordsCurrentFrame)){
			info("## A-star : destination IS reached! ##")	
		
			// sort in the opposite order AND remove duplicate frames
			var tmpChainAggression = buildChainAggression(beginningInfosFrame)
			var chainAggression = new ArrayList<InfosFrame>()
			var tmpFrame = tmpChainAggression.get(tmpChainAggression.size - 1)
			chainAggression.add(tmpFrame)
			for (var i=tmpChainAggression.size-2; i>=0; i--) {
				if (!(tmpFrame.uuidCurrentFrame === tmpChainAggression.get(i).uuidCurrentFrame)) {
					tmpFrame = tmpChainAggression.get(i)
					chainAggression.add(tmpFrame)
				}				
			}
			
			// YB
			var listSwap : ArrayList<Integer> = new ArrayList()
			
			info("---- Chain of aggression below ----")
			for(var i=0; i<chainAggression.size; i++){
				
				//Frame with the Tile which wants to move 
				if (chainAggression.get(i).coordsCurrentFrame.equals(beginningFrame.coordPair)) {
	
					info("BeginningFrame= " + chainAggression.get(i).coordsCurrentFrame.toString)
					
					for (var j = 0; j < frameList.size; j++) {
						if (frameList.get(j).ID === chainAggression.get(i).uuidCurrentFrame) {
	
							// YB
							listSwap.add(frameList.get(j).hostedNumTile)
	
							ctrl.setColor("green", frameList.get(j).hostedNumTile)
	
							// YB
							//Thread.sleep(100)
	
							break
						}
					}
				}
				
				// colorize the chain of aggression (NOT the extremities)
				else if (!chainAggression.get(i).coordsCurrentFrame.equals(arrivalFrame.coordPair)) {
	
					info("Frame"+(i + 1) + "= " + chainAggression.get(i).coordsCurrentFrame.toString)
					
					for(var j=0; j<frameList.size; j++){
						if (frameList.get(j).ID === chainAggression.get(i).uuidCurrentFrame) {
	
							// YB
							listSwap.add(frameList.get(j).hostedNumTile)
							
							ctrl.setColor("blue", frameList.get(j).hostedNumTile)
							
							break
						}
					}
				}
				else {
					info("ArrivalFrame= " + chainAggression.get(i).coordsCurrentFrame.toString)
				}
			}
			
			//Thread.sleep(500)

			// YB
			Collections.reverse(listSwap)
			for (number : listSwap) {
				ctrl.swap(number)
				//Thread.sleep(200)
			}
			
			ctrl.swap(haveTokenFrame.hostedNumTile)
			
			// swap tiles in the chain of aggression (ex: 12345 --> 51234)
			swapTilesInChainAggression(chainAggression)
			swapTokenAndBlank
			
			resetAllObjects
			
			info("BLANK EST : "+ blankTile.numFrameHost)
			emit(new TokenReleased)
				
		} else {
			error("## A-star : destination IS NOT reached! ##")
		}
			
	}
	
	// reset/clear/remove every objects used previously (TODO: add every others if necessary)
	def resetAllObjects {
		openListOfFrames.clear
		closedListOfFrames.clear
		ctrl.reset
	}
	
	// receive the event to execute the algo A*
	on FindPathWithAstarAlgo {
		uuidFRAMEbeginning = occurrence.beginningFrame
		
		for(var i=0; i<frameList.size; i++){
			if(frameList.get(i).ID === uuidFRAMEbeginning){
				beginningFrame = frameList.get(i)
				coordsFRAMEbeginning = frameList.get(i).coordPair
				var infosFrame = new InfosFrame(uuidFRAMEbeginning, coordsFRAMEbeginning) 
				beginningInfosFrame = infosFrame
				break
			}
		}
		
		// if you want to LOG numTile/uuidNumTile before the swap
		/*info("====================== receive event FINDPATH /beginningFrame.hostedNumTile="+beginningFrame.hostedNumTile)
		info("---------- Infos for numTile/uuidNumTile before the swap ----------")
		info("[0]= "+blankTile.ID)
		for(var ii=0; ii<tileList.size; ii++){
			for(ite: tileList){
				if(ite.numTile === ii+1){
					info("["+(ii+1)+"]= "+ite.ID)
				}
			}
		}
		info("-------------------------------------------------------------------")*/

		// there is a path
		if(beginningFrame.ID != arrivalFrame.ID){
			// TODO: NOT PRECISE AT ALL : more delay if bigger size
			if (PROBLEM_SIZE < 10)
				in(400 * PROBLEM_SIZE)[findPath]
			else
				in(600 * PROBLEM_SIZE)[findPath]				
		}
		// we just have to swap the FrameWithTokenTile and the FrameWithBlankTile because beginningFrame==arrivalFrame
		else {

			info("############# AGGRESSION DE LA BLANK TOUTE SEULE")
			ctrl.swap(haveTokenFrame.hostedNumTile)
			swapTokenAndBlank
			
			emit(new TokenReleased)
			
		}
	}
	
	def changeSatisfaction{

		for (var i=0; i<frameList.size-1; i++) {
			if (frameList.get(i).idNum === frameList.get(i).hostedNumTile) {
				// info("--> frame[" + frameList.get(i).idNum + "] is satisfied !")
				frameList.get(i).isSatisfied = true				
			}
			else
			{
				// info("--> frame[" + frameList.get(i).idNum + "] is not satisfied")
				frameList.get(i).isSatisfied = false
			}
		}
		
		for (iteTile : tileList) {
			if (iteTile.numTile === iteTile.numFrameHost) {
				// info("--> tile[" + iteTile.numTile + "] is satisfied !")
				iteTile.setIsHappy(true)
			} else {
				// info("--> tile[" + iteTile.numTile + "] is not satisfied")
				iteTile.setIsHappy(false)	
			}
		}
	}

	def swapTokenAndBlank {
		// tiles ----------------------------------------------------------
		var tmpTOKENtileUuid : UUID
		var tmpTOKENtileNum : int
		var tmpBLANKtileUuid : UUID
		var tmpBLANKtileNum : int 
		var tokenTile : TileAgent

		for (var i = 0; i < tileList.size; i++) {
			if (tileList.get(i).uuidFrameHost === haveTokenFrame.ID) {
				tokenTile = tileList.get(i)
				tmpTOKENtileUuid = tileList.get(i).uuidFrameHost
				tmpTOKENtileNum = tileList.get(i).numFrameHost
			} 
		}
		
		// for blankTile (arrivalFrame)
		tmpBLANKtileUuid = blankTile.uuidFrameHost
		tmpBLANKtileNum = blankTile.numFrameHost
		tokenTile.uuidFrameHost = tmpBLANKtileUuid
		tokenTile.numFrameHost = tmpBLANKtileNum
		tokenTile.numFrameHostFromZero = tokenTile.numFrameHost-1
		blankTile.uuidFrameHost = tmpTOKENtileUuid
		blankTile.numFrameHost = tmpTOKENtileNum
		
		// frames ---------------------------------------------------------
		initArrivalInfosFrame(haveTokenFrame.numFrame, haveTokenFrame.ID, haveTokenFrame.coordPair) // reset arrivalInfosFrame
		initBeginningInfosFrame(arrivalFrame.numFrame, arrivalFrame.ID, arrivalFrame.coordPair) // reset arrivalInfosFrame
		var tmpF = haveTokenFrame
		haveTokenFrame = arrivalFrame
		arrivalFrame = tmpF
		var tmpHostedTile = haveTokenFrame.hostedTile
		var tmpHostedNumTile = haveTokenFrame.hostedNumTile
		haveTokenFrame.hostedTile = arrivalFrame.hostedTile
		haveTokenFrame.hostedNumTile = arrivalFrame.hostedNumTile
		arrivalFrame.hostedTile = tmpHostedTile
		arrivalFrame.hostedNumTile = tmpHostedNumTile
		

		// if you want to LOG
		info(" ")
		info("=============== swapTokenAndBlank ===============")		
		info("---------- Infos FRAMES for numTile/uuidTile after the swap ----------")
		info("haveTokenFrame: idNum=" + haveTokenFrame.idNum + " /numHostedTile=" + haveTokenFrame.hostedNumTile)
		info("arrivalFrame: idNum=" + arrivalFrame.idNum + " /numHostedTile=" + arrivalFrame.hostedNumTile)
		for (var n = 0; n < frameList.size; n++) {
			for (ite : frameList) {
				if (ite.idNum === n + 1) {
					info("frame[" + (n + 1) + "]= tile: " + ite.hostedNumTile + " / " + ite.hostedTile)
				}
			}
		}
		info("---------- Infos TILES for numFrame/uuidFrame after the swap ----------")
		info("tile[0]= frame: " + blankTile.numFrameHost + " /" + blankTile.uuidFrameHost)
		for (var n = 0; n < tileList.size; n++) {
			for (ite : tileList) {
				if (ite.numTile === n + 1) {
					info("tile[" + (n + 1) + "]= frame: " + ite.numFrameHost + " / " + ite.uuidFrameHost 
						+" /framehostfromzero=" + ite.numFrameHostFromZero + " /numTileFromZero=" +
						ite.numTileFromZero)
				}
			}
		}
		info("------------------------------------------------------------------") 
				
		changeSatisfaction
	}
	
	def initArrivalInfosFrame(num: int, uuid: UUID, coord: CoordPair){
		arrivalInfosFrame = new InfosFrame(uuid, coord)
		arrivalInfosFrame.numFrame = num
	}

	def initBeginningInfosFrame(num : int, uuid : UUID, coord : CoordPair) {
		beginningInfosFrame = new InfosFrame(uuid, coord)
		beginningInfosFrame.numFrame = num
	}
	
	// swap all tiles in the chain of aggression (ex: 12345 --> 51234)
	def swapTilesInChainAggression(chainAggression : ArrayList<InfosFrame>){
		var tmpFRAMEuuidHostedTile : UUID
		var tmpFRAMEnumHostedTile : int
		var tmpTILEuuidFrameHost : UUID
		var tmpTILEnumFrameHost : int
		var tmp1 : UUID 	// tile.uuidFrameHost
		var tmp2 : int		// tile.numFrameHost
		//var tmp3 : int		// tile.numFrameHostFromZero
		var tmp11 : UUID	// same
		var tmp22 : int		// same
		//var tmp33 : int		// same
		 
		// browse the chain of aggression in the opposite direction 
		for(var i=chainAggression.size-1; i>=0; i--){
			
			// search the corresponded FRAME of the current element in chainAggression
			for(var j=0; j<frameList.size; j++){
				if(frameList.get(j).ID === chainAggression.get(i).uuidCurrentFrame){
					
					var tmpBlankTile : EmptyTileAgent
					var tmpTile : TileAgent
					for(var iTile=0; iTile<tileList.size; iTile++){
						if(tileList.get(iTile).ID === frameList.get(j).hostedTile){
							tmpTile = tileList.get(iTile)
							break		
						}
					}
							
					// the first operation to do : save the infos of the last element in chainAggression
					if(i == chainAggression.size-1){
						tmpFRAMEuuidHostedTile = frameList.get(j).hostedTile
						tmpFRAMEnumHostedTile = frameList.get(j).hostedNumTile 
						tmpTILEuuidFrameHost = blankTile.uuidFrameHost
						tmpTILEnumFrameHost = blankTile.numFrameHost
					}
					
					// the intermediates operations to do for elements 0<i<=N in chainAggression 
					if (i > 0) {
						// search the FRAME corresponding to the index (i-1) for the loop
						for(var k=0; k<frameList.size; k++){
							if (frameList.get(k).ID === chainAggression.get(i - 1).uuidCurrentFrame) {
								
								for(var jTile=0; jTile<tileList.size; jTile++){
									if (tileList.get(jTile).ID === frameList.get(k).hostedTile) {
										tmp1 = tileList.get(jTile).uuidFrameHost
										tmp2 = tileList.get(jTile).numFrameHost
																				
										// first element
										if(i==chainAggression.size-1){
											tmp11 = tileList.get(jTile).uuidFrameHost
											tmp22 = tileList.get(jTile).numFrameHost
											tileList.get(jTile).uuidFrameHost = blankTile.uuidFrameHost
											tileList.get(jTile).numFrameHost = blankTile.numFrameHost
											tileList.get(jTile).numFrameHostFromZero = blankTile.numFrameHost-1
										}
										// others
										else {
											tileList.get(jTile).uuidFrameHost = tmp11
											tileList.get(jTile).numFrameHost = tmp22
											tileList.get(jTile).numFrameHostFromZero = tileList.get(jTile).numFrameHost-1
											tmp11 = tmp1
											tmp22 = tmp2
										}
										break
									}
								}
								
								frameList.get(j).hostedTile = frameList.get(k).hostedTile
								frameList.get(j).hostedNumTile = frameList.get(k).hostedNumTile
								break
							}
						}
					}
					
					// the last operation to do : use the previously saved infos for the element O in chainAggression
					else {						
						frameList.get(j).hostedTile = blankTile.ID
						frameList.get(j).hostedNumTile = blankTile.numTile
						blankTile.uuidFrameHost = frameList.get(j).ID
						blankTile.numFrameHost = frameList.get(j).idNum
						arrivalFrame = frameList.get(j)
					}				
				}				
			}
		}
		
		// if you want to LOG
		/*info("---------- Infos FRAMES for numTile/uuidTile after the swap ----------")
		info("arrivalFrame= " + arrivalFrame.idNum + " / " + arrivalFrame.ID)
		for(var n=0; n<frameList.size; n++){
			for(ite: frameList){
				if(ite.idNum === n+1){
					info("frame["+(n+1)+"]= tile: "+ite.hostedNumTile+" / "+ite.hostedTile)
				}
			}
		}

		info("---------- Infos TILES for numFrame/uuidFrame after the swap ----------")
		info("tile[0]= frame: "+blankTile.numFrameHost + " /" + blankTile.uuidFrameHost)
		for (var n = 0; n < tileList.size; n++) {
			for (ite : tileList) {
				if (ite.numTile === n + 1) {
					info("tile[" + (n + 1) + "]= frame: " + ite.numFrameHost + " / " + ite.uuidFrameHost)
				}
			}
		}
		info("------------------------------------------------------------------")*/
		
		changeSatisfaction
	}

	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
	}
 
	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}
}
