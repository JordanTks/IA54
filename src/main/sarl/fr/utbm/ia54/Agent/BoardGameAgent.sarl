/** 
 * 
 */
package fr.utbm.ia54.Agent

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Lifecycle
import fr.utbm.ia54.Event.GameSet
import fr.utbm.ia54.Event.FrameSatisfied
import io.sarl.core.DefaultContextInteractions
import java.util.ArrayList
import java.util.List
import java.util.Collections
import fr.utbm.ia54.Event.FrameSet
import fr.utbm.ia54.Event.GameCompleted
import fr.utbm.ia54.Event.TileSet
import fr.utbm.ia54.Event.TokenReceived
import java.util.UUID
import io.sarl.util.Scopes
import fr.utbm.ia54.Event.TokenReleased
import java.util.HashMap
import io.sarl.core.Behaviors
import java.util.Map
import java.util.Iterator

/** 
 * @author Jordan
 * 
 */
agent BoardGameAgent {
	uses Logging, Lifecycle, DefaultContextInteractions, Behaviors
	
	val PROBLEM_SIZE = 3
	var nbFrameSet = 0
	var nbTileSet = 0
	var tileList = new ArrayList<TileAgent>()
	var tokenPriorityList = new ArrayList<ArrayList<TileAgent>>()
	
	//var nbFrameSatisfied = 0 // probablement inutile
	
	on Initialize {

		loggingName = 'BoardGameAgent'

		val frameList : List<Integer> = new ArrayList

		for (var i = 1; i <= Math.pow(PROBLEM_SIZE, 2); i++)
			frameList.add(i)

		for (var i = 0; i <= Math.pow(PROBLEM_SIZE, 2) - 1; i++) // spawn FrameAgent
			spawn(FrameAgent, #[frameList.get(i), i / PROBLEM_SIZE, i % PROBLEM_SIZE, PROBLEM_SIZE])
		
		info("Board game has been set.")
	}

	on FrameSet {
		
		nbFrameSet++

		// ouais c'est bon on est tous lÃ  !
		if (nbFrameSet === Math.round(Math.pow(PROBLEM_SIZE, 2)))
		{
			info("Every single FrameAgent is set. Spawning every single TileAgent.")
			
			var startingTiles : List<Integer> = new ArrayList
			
			for (var i = 1; i < Math.pow(PROBLEM_SIZE, 2); i++)
				startingTiles.add(i)

			Collections.shuffle(startingTiles)

			info("Starting positions " + startingTiles)
			
			var order = new HashMap<Integer, UUID>()
			
			for (var i = 0; i < Math.pow(PROBLEM_SIZE, 2) - 1; i++) { // spawn TileAgent num tile / num frame
				//var agentUUID =
				spawn(TileAgent, #[startingTiles.get(i), i, PROBLEM_SIZE])
				//var agentNumber = 
				Math.min((startingTiles.get(i) - 1) / PROBLEM_SIZE, (startingTiles.get(i) - 1) % PROBLEM_SIZE)
				//info("test 123 : " + startingTiles.get(i) + "  " + agentNumber)
				// order.put(agentNumber, agentUUID)
			}

			//info("hh:"+order.values)

			
			// spawn tileblanck
			spawn(EmptyTileAgent)			
		}
	}
	
	on TileSet {
		
		nbTileSet++
		info("test 1234 : ")
		
		if (occurrence.tile !== null) // DO NOT REMOVE THIS TEST
			tileList.add(occurrence.tile)


		if (nbTileSet === Math.round(Math.pow(PROBLEM_SIZE, 2))) {
			info("Every single TileAgent is set. Sending a token.")
			
			// Setting token priority lists
			for (var i = 1; i < PROBLEM_SIZE; i++)
				tokenPriorityList.add(new ArrayList())
			
			// Put the tile in the right tokenPriority list
			for (t : tileList)
				tokenPriorityList.get(t.getTokenPriority).add(t)

			info("test 123 : ")

			for (t : tokenPriorityList)		
			{
				var n = t.size  
			    var temp : TileAgent  
			    
	         	for(var i=0; i < n; i++)
				{  
	                 for(var j=1; j < (n-i); j++)
					{
						if (t.get(j - 1).tokenPriority > t.get(j).tokenPriority) {
							//swap elements
			                temp = t.get(j - 1)
							t.add((j - 1), t.get(j))
							t.add(j, temp)
						}
			
					}
				}
				info("test 123 : " + t)
			}
			// Sending the token
			wake(new TokenReleased)
		}
	}

	on TokenReleased {
		
		// Sending the token
		
		
		emit(new TokenReceived(2), Scopes.addresses(defaultSpace.getAddress(tokenPriorityList.get(0).get(0).ID)))
	}



	/* PROBABLEMENT DEJA OBSOLETE

	on FrameSatisfied {

		if (!occurrence.satisfied)
			nbFrameSatisfied--
		else
			if (nbFrameSatisfied === Math.round(Math.pow(PROBLEM_SIZE, 2)) - 1)
			{	
				info("Checking satisfaction of every Frame.") // in case of false positive due to synchronization issues
				// todo
				
				if (1 === 1)
				{
					info("Every Frame satisfied. Game completed.")
					emit(new GameCompleted)
				
				}
			}
	}*/

	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}
}
