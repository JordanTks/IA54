
package fr.utbm.ia54.Agent

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Lifecycle
import fr.utbm.ia54.Event.GameSet
import fr.utbm.ia54.Event.FrameSatisfied
import io.sarl.core.DefaultContextInteractions
import java.util.ArrayList
import java.util.List
import java.util.Collections
import fr.utbm.ia54.Event.FrameSet
import fr.utbm.ia54.Event.GameCompleted
import fr.utbm.ia54.Event.TileSet
import fr.utbm.ia54.Event.TokenReceived
import io.sarl.util.Scopes
import fr.utbm.ia54.Event.TokenReleased
import io.sarl.core.Behaviors
import fr.utbm.ia54.gui.TaquinFxViewerController
import fr.utbm.taquin.events.ActionUI
import java.util.UUID
import fr.utbm.ia54.Class.CoordPair
import fr.utbm.ia54.Class.InfosFrame
import java.util.LinkedHashSet
import io.sarl.core.Schedules

enum Position {
	NORTH,
	SOUTH,
	EAST,
	WEST
	;
}
 
agent BoardGameAgent {
	uses Logging, Lifecycle, DefaultContextInteractions, Behaviors, Schedules
	
	var PROBLEM_SIZE = 3
	var nbFrameSet = 0
	var nbTileSet = 0
	var frameList = new ArrayList<FrameAgent>()
	
	// TKS
	var frameUUIDList = new ArrayList<UUID>()
	var listCoordPairsOfFrames = new ArrayList<CoordPair>()
	
	var openListOfFrames = new ArrayList<InfosFrame>()
	var closedListOfFrames = new ArrayList<InfosFrame>()

	// infos of the frame on which there is the Tile with the Token
	var beginningInfosFrame : InfosFrame
	var uuidFRAMEwithTokenTile : UUID
	var coordsFRAMEwithTokenTile : CoordPair
	
	// infos of the frale on which there is the BlankTile
	var arrivalFrame : FrameAgent
	var arrivalInfosFrame : InfosFrame
	var uuidFRAMEwithBlankTile : UUID
	var coordsFRAMEwithBlankTile : CoordPair
	
	var tileList = new ArrayList<TileAgent>()
	var tokenPriorityList = new ArrayList<ArrayList<TileAgent>>()

	var ctrl : TaquinFxViewerController

	
	on Initialize {

		loggingName = 'BoardGameAgent'

		PROBLEM_SIZE = occurrence.parameters.get(0) as Integer
		ctrl = occurrence.parameters.get(1) as TaquinFxViewerController

		val numFrameList : List<Integer> = new ArrayList // TKS: redondance de nom --> changement

		for (var i = 1; i <= Math.pow(PROBLEM_SIZE, 2); i++)
			numFrameList.add(i) // TKS

		for (var i = 0; i <= Math.pow(PROBLEM_SIZE, 2) - 1; i++) { // spawn FrameAgent(num,row,col,size)
		 	// TKS
			frameUUIDList.add(spawn(FrameAgent, #[numFrameList.get(i), i / PROBLEM_SIZE, i % PROBLEM_SIZE, PROBLEM_SIZE])) // get UUID of the frameAgent
			listCoordPairsOfFrames.add(new CoordPair((i / PROBLEM_SIZE), (i % PROBLEM_SIZE)))
		}
		
		info("Board game has been set.")		
	}
 
	on FrameSet {
		
		nbFrameSet++

		frameList.add(occurrence.frame)

		// ouais c'est bon on est tous là !
		if (nbFrameSet === Math.round(Math.pow(PROBLEM_SIZE, 2)))
		{
			info("Every single FrameAgent is set. Spawning every single TileAgent.")

			// Ordering initial list of frame in order to set neighbours
			Collections.sort(frameList)[a, b|a.numFrame - b.numFrame]
			
			// Setting neighbours
			var c = 0
			for (f : frameList)
			{
				if (c % PROBLEM_SIZE != 0) // when true, the frame does have a west neighbour
					f.setWestNeighbour(frameList.get(c - 1).ID)

				if (c / PROBLEM_SIZE != 0) // when true, the frame does have a north neighbour
					f.setNorthNeighbour(frameList.get(c - PROBLEM_SIZE).ID)

				if (c + PROBLEM_SIZE < (PROBLEM_SIZE * PROBLEM_SIZE)) // when true, the frame does have a south neighbour
					f.setSouthNeighbour(frameList.get(c + PROBLEM_SIZE).ID)

				if (c % PROBLEM_SIZE != (PROBLEM_SIZE - 1)) // when true, the frame does have a east neighbour
					f.setEastNeighbour(frameList.get(c + 1).ID)
				
				c++
			}
			
			// Shuffle tile positions
			var startingTiles : List<Integer> = new ArrayList
			
			for (var i = 1; i < Math.pow(PROBLEM_SIZE, 2); i++)
				startingTiles.add(i)

			Collections.shuffle(startingTiles)

			info("Starting positions " + startingTiles)

			// COMMUNICATION AVEC UI
			// emit(new InitDone(startingTiles))
			ctrl.monTest(startingTiles);
			
			// Spawn tile agents (num tile/UUID frame/num frame/ problem size)
			for (var i = 0; i < Math.pow(PROBLEM_SIZE, 2) - 1; i++)
			{
				var id = spawn(TileAgent, #[startingTiles.get(i), frameList.get(i).ID, i, PROBLEM_SIZE])
				frameList.get(i).hostedTile = id
				frameList.get(i).hostedNumTile = startingTiles.get(i)
				frameList.get(i).isSatisfied = (startingTiles.get(i) === frameList.get(i).numFrame)
			}
			
			// Spawn blank tile
			var id = spawn(EmptyTileAgent)
			frameList.get(PROBLEM_SIZE*PROBLEM_SIZE - 1).hostedTile = id
			uuidFRAMEwithBlankTile = frameList.get(PROBLEM_SIZE * PROBLEM_SIZE - 1).ID
			coordsFRAMEwithBlankTile = frameList.get(PROBLEM_SIZE * PROBLEM_SIZE - 1).coordPair
			arrivalInfosFrame = new InfosFrame(uuidFRAMEwithBlankTile, coordsFRAMEwithBlankTile)
			arrivalFrame = frameList.get(PROBLEM_SIZE * PROBLEM_SIZE - 1)
			info("///////////////// FrameSet) LAST IN frameList=" + frameList.get(PROBLEM_SIZE * PROBLEM_SIZE - 1).ID)
			info("///////////////// FrameSet) arrivalFrame.ID=" + arrivalFrame.ID)
		}
	}
	
	on TileSet {
		
		nbTileSet++
		
		if (occurrence.tile !== null) // DO NOT REMOVE THIS TEST
			tileList.add(occurrence.tile)

		if (nbTileSet === Math.round(Math.pow(PROBLEM_SIZE, 2))) {
			info("Every single TileAgent is set. Setting token priority lists.")

			// Ordering initial list by numTile to avoid later more complicated computation
			Collections.sort(tileList)[a, b|a.numTile - b.numTile]
					
			var tempList = new ArrayList<TileAgent>()
							
			// Setting token priority lists
			for (var i = 1; i < PROBLEM_SIZE; i++)
				tokenPriorityList.add(new ArrayList())
			
			// Put the tile in the right tokenPriority list
			for (t : tileList)
				tokenPriorityList.get(t.getTokenPriority).add(t)

			// Modify the sorting of each list
			for (l : tokenPriorityList)		
			{
				for (var tilesToSwitch = (l.size / 2) + 1; tilesToSwitch > 0 ; tilesToSwitch--)
				{
					tempList.add(l.get(0))
					l.remove(0)
				}
				
				while (!tempList.empty)
				{
					l.add(0, tempList.get(0))
					tempList.remove(0)
				}
				
				//for (t : l)
				//	info(t.numTile)
			}

			info("TokenPriorityList data set up.")
			
			// Sending the token
			wake(new TokenReleased)

			// Wait until every agent is spawned
			info("*************** nbFrameSet=" + nbFrameSet+" /nbTileSet="+nbTileSet)
			info("!!!!!!!!!!!!! BEGIN TEST OF the A-star ALGORITHM !!!!!!!!!!!!!")
			
			//TODO: NOT PRECISE AT ALL : more delay if bigger size
			if(PROBLEM_SIZE<10)
				in(250 * PROBLEM_SIZE)[findPath]
			else
				in(300 * PROBLEM_SIZE)[findPath]
		}
	}

	on TokenReleased {
		
		// Looking for the first unsatisfied tile on the first priority list
		do {
			for (t : tokenPriorityList.get(0))
			{
				if (!t.isHappy)
				{
					emit(new TokenReceived(), Scopes.addresses(defaultSpace.getAddress(t.ID)))
					
					// set the infosFrame for the frame on which there is the Tile with the Token
					for(var i=0; i<frameList.size; i++){
						if(frameList.get(i).hostedTile === t.ID){
							uuidFRAMEwithTokenTile = frameList.get(i).ID
							coordsFRAMEwithTokenTile = frameList.get(i).coordPair
							beginningInfosFrame = new InfosFrame(uuidFRAMEwithTokenTile, coordsFRAMEwithTokenTile)
							info("++++++++++++++++++++++++++++ TokenReleased) beginningFrame=" + uuidFRAMEwithTokenTile)
							break
						}
					}
					
					
					return
				}
			}
			
			tokenPriorityList.remove(0)
			
			// It is over
			if (tokenPriorityList.empty)
				return
			// Else ... get to the next list by looping
			
		} while (!tokenPriorityList.empty)
	}

	on ActionUI {
//		info("JE VAIS FAIRE CHANGER COULEUR.")
		ctrl.setColor(occurrence.prop, occurrence.target)
	}
	
	/** 
	 * calculate the euclidean distance between 2 frames
	 * @params a,b : 2 FrameAgent
	 * @return int: square euclidean distance
	 */
	 // TKS
	def distEuclidian(a : FrameAgent, b : FrameAgent) : int {
		return ((a.XRow - b.XRow) * (a.XRow - b.XRow) + (a.YCol - b.YCol) * (a.YCol - b.YCol))
	}
	
	/** 
	 * determinate if the frame is in the list
	 * @params pair, listOfFrames : CoordPair & ArrayList<InfosFrame>
	 * @return boolean: true if the CoordPair correspond to coords of an FrameAgent in the list
	 */
	 // TKS
	def isInFrameList(pair : CoordPair, listOfFrames : ArrayList<InfosFrame>) : boolean {
		for (fa : listOfFrames) {
			 if(pair.equals(fa.coordsCurrentFrame))
			 	return true
		}
		return false
	}
	
	/** 
	 * add the neighbour's frames of the current frame
	 * @params currentFrame: the current FrameAgent
	 */
	 // TKS
	def addNeighbourFrames(currentFrame : FrameAgent)
	{			
		if(arrivalFrame != null)
			info("////////////////////// addNeighbour) arrivalFrame.UUID="+arrivalFrame.ID)
		else info("///////////////////// addNeighbour) arrivalFrame NULL")
		
		// the north's frame exists======================================================================================================================
		if (currentFrame.northNeighbour != null) {
			var index = frameUUIDList.indexOf(currentFrame.northNeighbour)

			// TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
			if (!frameList.get(index).isSatisfied) {

				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var newCoords = frameList.get(index).coordPair

				// if doesn't exist in the closed list
				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {

					// the treated frame (stock the infos)
					var infosFrame = new InfosFrame(currentFrame.northNeighbour, coordNeighbour)

					// costG of north's neighbour: cost of previous + distance to previous
					var indexForClosedList = -1
					for (iterator : closedListOfFrames) {
						indexForClosedList++
						if (iterator.uuidCurrentFrame == currentFrame.ID)
							break
					}

					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
						distEuclidian(frameList.get(index), currentFrame)

					// TODO: ATTENTION ! DOIT ETRE LA FRAME POSSEDANT LA BLANKTILE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//					var arrivalFrame = frameList.get(((PROBLEM_SIZE * PROBLEM_SIZE) - 1)) // TKS: modify with the frame which has the blankTile
					// costH of north's neighbour: it to arrival
					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
					infosFrame.costF = infosFrame.costG + infosFrame.costH

					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
					infosFrame.uuidPreviousFrame = currentFrame.ID
					infosFrame.coordsPreviousFrame = currentFrame.coordPair

					var indexForOpenList = -1
					for (iterator : openListOfFrames) {
						indexForOpenList++
						if (iterator.uuidCurrentFrame == currentFrame.northNeighbour)
							break
					}

					// if already exists: compare the cost
					if (isInFrameList(coordNeighbour, openListOfFrames)) {
						// only if the new path is shorter: update it ELSE do nothing
						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF)
							openListOfFrames.set(indexForOpenList, infosFrame)
						
					} // the treated frame (north's frame) is not in the openList yet: add it
					else {
						openListOfFrames.add(infosFrame)
					}
				}
			}
		}

		// the south's frame exists======================================================================================================================
		if (currentFrame.southNeighbour != null) {
			var index = frameUUIDList.indexOf(currentFrame.southNeighbour)

			// TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
			if (!frameList.get(index).isSatisfied) {

				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var newCoords = frameList.get(index).coordPair

				// if doesn't exist in the closed list
				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {

					// the treated frame (stock the infos)
					var infosFrame = new InfosFrame(currentFrame.southNeighbour, coordNeighbour)

					// costG of south's neighbour: cost of previous + distance to previous
					var indexForClosedList = -1
					for (iterator : closedListOfFrames) {
						indexForClosedList++
						if (iterator.uuidCurrentFrame == currentFrame.ID)
							break
					}

					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
						distEuclidian(frameList.get(index), currentFrame)

					// TODO: ATTENTION ! DOIT ETRE LA FRAME POSSEDANT LA BLANKTILE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//					var arrivalFrame = frameList.get(((PROBLEM_SIZE * PROBLEM_SIZE) - 1)) // TKS: modify with the frame which has the blankTile
					// costH of south's neighbour: it to arrival
					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
					infosFrame.costF = infosFrame.costG + infosFrame.costH

					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
					infosFrame.uuidPreviousFrame = currentFrame.ID
					infosFrame.coordsPreviousFrame = currentFrame.coordPair

					var indexForOpenList = -1
					for (iterator : openListOfFrames) {
						indexForOpenList++
						if (iterator.uuidCurrentFrame == currentFrame.southNeighbour)
							break
					}

					// if already exists: compare the cost
					if (isInFrameList(coordNeighbour, openListOfFrames)) {
						// only if the new path is shorter: update it ELSE do nothing
						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF) 
							openListOfFrames.set(indexForOpenList, infosFrame)
						
					} // the treated frame (south's frame) is not in the openList yet: add it
					else {
						openListOfFrames.add(infosFrame)
					}
				}
			}
		}

		// the east's frame exists======================================================================================================================
		if (currentFrame.eastNeighbour != null) {
			var index = frameUUIDList.indexOf(currentFrame.eastNeighbour)

			// TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
			if (!frameList.get(index).isSatisfied) {

				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var newCoords = frameList.get(index).coordPair
												
				// if doesn't exist in the closed list
				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {

					// the treated frame (stock the infos)
					var infosFrame = new InfosFrame(currentFrame.eastNeighbour, coordNeighbour)

					// costG of east's neighbour: cost of previous + distance to previous
					var indexForClosedList = -1
					for (iterator : closedListOfFrames) {
						indexForClosedList++
						if (iterator.uuidCurrentFrame == currentFrame.ID)
							break
					}

					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
						distEuclidian(frameList.get(index), currentFrame)

					// TODO: ATTENTION ! DOIT ETRE LA FRAME POSSEDANT LA BLANKTILE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//					var arrivalFrame = frameList.get(((PROBLEM_SIZE * PROBLEM_SIZE) - 1)) // TKS: modify with the frame which has the blankTile
					// costH of east's neighbour: it to arrival
					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
					infosFrame.costF = infosFrame.costG + infosFrame.costH

					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
					infosFrame.uuidPreviousFrame = currentFrame.ID
					infosFrame.coordsPreviousFrame = currentFrame.coordPair

					var indexForOpenList = -1
					for (iterator : openListOfFrames) {
						indexForOpenList++
						if (iterator.uuidCurrentFrame == currentFrame.eastNeighbour)
							break
					}

					// if already exists: compare the cost
					if (isInFrameList(coordNeighbour, openListOfFrames)) {
						// only if the new path is shorter: update it ELSE do nothing
						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF) 
							openListOfFrames.set(indexForOpenList, infosFrame)
						
					} // the treated frame (east's frame) is not in the openList yet: add it
					else {
						openListOfFrames.add(infosFrame)
					}
				}
			}
		}

		// the west's frame exists======================================================================================================================
		if (currentFrame.westNeighbour != null) {
			var index = frameUUIDList.indexOf(currentFrame.westNeighbour)

			//TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
			if (!frameList.get(index).isSatisfied) {

				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var newCoords = frameList.get(index).coordPair
												
				// if doesn't exist in the closed list
				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {

					// the treated frame (stock the infos)
					var infosFrame = new InfosFrame(currentFrame.westNeighbour, coordNeighbour)

					// costG of west's neighbour: cost of previous + distance to previous
					var indexForClosedList = -1
					for (iterator : closedListOfFrames) {
						indexForClosedList++
						if (iterator.uuidCurrentFrame == currentFrame.ID)
							break
					}
					
					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
						distEuclidian(frameList.get(index), currentFrame)

					// TODO: ATTENTION ! DOIT ETRE LA FRAME POSSEDANT LA BLANKTILE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//					var arrivalFrame = frameList.get(((PROBLEM_SIZE * PROBLEM_SIZE) - 1)) // TKS: modify with the frame which has the blankTile
					// costH of west's neighbour: it to arrival
					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
					infosFrame.costF = infosFrame.costG + infosFrame.costH

					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
					infosFrame.uuidPreviousFrame = currentFrame.ID
					infosFrame.coordsPreviousFrame = currentFrame.coordPair

					var indexForOpenList = -1
					for (iterator : openListOfFrames) {
						indexForOpenList++
						if (iterator.uuidCurrentFrame == currentFrame.westNeighbour)
							break
					}

					// if already exists: compare the cost
					if (isInFrameList(coordNeighbour, openListOfFrames)) {
						// only if the new path is shorter: update it ELSE do nothing
						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF)
							openListOfFrames.set(indexForOpenList, infosFrame)
						
					} // the treated frame (west's frame) is not in the openList yet: add it
					else {
						openListOfFrames.add(infosFrame)
					}
				}
			}
		}
	} // end of addNeighbourFrames()
	
	
	/** 
	 * get the frame with best cost from the frameList
	 * @param listFrames: list of InfosFrame
	 * @return InfosFrame: the infosFrame with the best (lower) cost OR null if the list is empty
	 */
	 // TKS
def getBestFrame(listFrames : ArrayList<InfosFrame>) : InfosFrame {
		if(!listFrames.empty){ // the list is not empty
			var costF = listFrames.get(0).costF
			var infoFrame = listFrames.get(0)
			
			for(frame : listFrames){
				if(frame.costF < costF){ // get the lower cost in the list
					costF = frame.costF
					infoFrame = frame
				}
			}
			return infoFrame
		}
		
		return null		
	}
	
	/** 
	 * add the InfosFrame in the closedList and remove it from the openList
	 * @param coords: CoordPair of the frame to manipulate
	 */
	 // TKS
	def addInClosedList(coords : CoordPair){
		var index = -1
		for(ite : openListOfFrames){
			index++
			if(ite.coordsCurrentFrame.equals(coords)){ // found it in the openList
				closedListOfFrames.add(ite) 	// add in the closedList
				break
			}				
		}
		openListOfFrames.remove(index) // remove it from the openList
	}
	
	/** 
	 * get the chain of aggression in a list of InfosFrame
	 * return ArrayList<InfosFrame>: the list of InfosFrame for the aggression in the right order
	 */
	 // TKS
	def buildChainAggression(beginningFrame : InfosFrame) : ArrayList<InfosFrame> {
		var chain = new ArrayList<InfosFrame>
		var index = closedListOfFrames.size-1
		var tmpFrame : InfosFrame
		var prevFrame : InfosFrame
		var flagEnd = false
		
		// the last one is the arrivalFrame
		tmpFrame = closedListOfFrames.get(index)
		chain.add(tmpFrame)
		
		// get the previousFrame of the first one
		prevFrame = new InfosFrame(tmpFrame.uuidPreviousFrame,tmpFrame.coordsPreviousFrame)
				
		// loop with each previousFrame of the currentFrame treated
		while(!prevFrame.equals(beginningFrame)){		
			chain.add(prevFrame)
			
			var i = -1
			for(ite : closedListOfFrames){
				
				// the end
				if(tmpFrame.coordsPreviousFrame==null){ 
					flagEnd = true
					break	
				}
					
				i++
				if(ite.coordsCurrentFrame.equals(tmpFrame.coordsPreviousFrame))
					break
			}
			
			// looping on the closedList
			if(!flagEnd){
				tmpFrame = closedListOfFrames.get(i)
				prevFrame = new InfosFrame(closedListOfFrames.get(i).uuidCurrentFrame, closedListOfFrames.get(i).coordsCurrentFrame)
			}
			
			// the end of the loop
			else break
		}
		
		return chain
	}
	
	/** 
	 * execute the A-star algorithm
	 */
	 // TKS
	def findPath {
		
//		val beginningFrameTMP = new InfosFrame(frameUUIDList.get(0), listCoordPairsOfFrames.get(0)) // TODO: CHANGE WITH THE FRAME ON WHICH THE FILE HAS THE TOKEN
//		val arrivalFrame = new InfosFrame(frameUUIDList.get((PROBLEM_SIZE * PROBLEM_SIZE) - 1),listCoordPairsOfFrames.get((PROBLEM_SIZE * PROBLEM_SIZE) - 1))
		var currentFrame = beginningInfosFrame
		
		openListOfFrames.add(beginningInfosFrame)
		addInClosedList(beginningInfosFrame.coordsCurrentFrame)
		
		// get the frame with the index of FrameList
		var indexOfFrameList = -1
		for(ite : frameList){
			indexOfFrameList++
			if (ite.coordPair.equals(beginningInfosFrame.coordsCurrentFrame))
				break
		}
		
		// add the neighbours in the openList
		addNeighbourFrames(frameList.get(indexOfFrameList))
		
		// until the destination has been reached && openList is empty
		while(!currentFrame.coordsCurrentFrame.equals(arrivalInfosFrame.coordsCurrentFrame) && !openListOfFrames.empty){
			currentFrame = getBestFrame(openListOfFrames)
			addInClosedList(currentFrame.coordsCurrentFrame)
			
			var indexOfFrameList2 = -1
			for(ite : frameList){
				indexOfFrameList2++
				if (ite.coordPair.equals(currentFrame.coordsCurrentFrame))
					break
			}	
			addNeighbourFrames(frameList.get(indexOfFrameList2))
		}
		
		// if destination is reached : build the path in the opposite direction of the chain of aggression
		if(currentFrame.coordsCurrentFrame.equals(arrivalInfosFrame.coordsCurrentFrame)){
			info("######## A-star : destination IS reached !")
		} else {
			info("######## A-star : destination IS NOT reached !")
		}
		
		
		// sort in the opposite order AND remove duplicate frames
		var tmpChainAggression = buildChainAggression(beginningInfosFrame)
		var chainAggression = new ArrayList<InfosFrame>()
		var tmpFrame = tmpChainAggression.get(tmpChainAggression.size - 1)
		chainAggression.add(tmpFrame)
		for (var i=tmpChainAggression.size-2; i>=0; i--) {
			if (!(tmpFrame.uuidCurrentFrame === tmpChainAggression.get(i).uuidCurrentFrame)) {
				tmpFrame = tmpChainAggression.get(i)
				chainAggression.add(tmpFrame)
			}				
		}
		
		info("---- Chain of aggression below ----")
		for(ite : chainAggression){
			info("path="+ite.coordsCurrentFrame.toString+" /ID="+ite.uuidCurrentFrame)
			
			// colorize the chain of aggression BUT not the beginningFrame
			if (!ite.coordsCurrentFrame.equals(coordsFRAMEwithTokenTile)) {
				for(var i=0; i<frameList.size; i++){
					if(frameList.get(i).ID === ite.uuidCurrentFrame){
						emit(new ActionUI("green", frameList.get(i).hostedNumTile), Scopes.addresses(defaultSpace.getAddress(ID)))
						break
					}
				}
			}
		}
			
	}

	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}
}
