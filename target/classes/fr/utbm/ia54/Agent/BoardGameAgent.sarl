/** 
 * 
 */
package fr.utbm.ia54.Agent

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Lifecycle
import fr.utbm.ia54.Event.GameSet
import fr.utbm.ia54.Event.FrameSatisfied
import io.sarl.core.DefaultContextInteractions
import java.util.ArrayList
import java.util.List
import java.util.Collections
import fr.utbm.ia54.Event.FrameSet
import fr.utbm.ia54.Event.GameCompleted
import fr.utbm.ia54.Event.TileSet
import fr.utbm.ia54.Event.TokenReceived
import java.util.UUID
import io.sarl.util.Scopes
import fr.utbm.ia54.Event.TokenReleased
import java.util.HashMap
import io.sarl.core.Behaviors
import java.util.Map
import java.util.Iterator

/** 
 * @author Jordan
 * 
 */
 
enum position {
	NORTH,
	SOUTH,
	EAST,
	WEST
	;
}
 
agent BoardGameAgent {
	uses Logging, Lifecycle, DefaultContextInteractions, Behaviors
	
	val PROBLEM_SIZE = 3
	var nbFrameSet = 0
	var nbTileSet = 0
	var frameList = new ArrayList<FrameAgent>()
	var tileList = new ArrayList<TileAgent>()
	var tokenPriorityList = new ArrayList<ArrayList<TileAgent>>()
	
	//var nbFrameSatisfied = 0 // probablement inutile
	
	
	on Initialize {

		loggingName = 'BoardGameAgent'

		val frameList : List<Integer> = new ArrayList

		for (var i = 1; i <= Math.pow(PROBLEM_SIZE, 2); i++)
			frameList.add(i)

		for (var i = 0; i <= Math.pow(PROBLEM_SIZE, 2) - 1; i++) // spawn FrameAgent
			spawn(FrameAgent, #[frameList.get(i), i / PROBLEM_SIZE, i % PROBLEM_SIZE, PROBLEM_SIZE])
		
		info("Board game has been set.")
	}

	on FrameSet {
		
		nbFrameSet++

		frameList.add(occurrence.frame)

		// ouais c'est bon on est tous lÃ  !
		if (nbFrameSet === Math.round(Math.pow(PROBLEM_SIZE, 2)))
		{
			info("Every single FrameAgent is set. Spawning every single TileAgent.")

			// Ordering initial list of frame in order to set neighbours
			Collections.sort(frameList)[a, b|a.numFrame - b.numFrame]
			
			// Setting neighbours
			var c = 0
			for (f : frameList)
			{
				if (c % PROBLEM_SIZE != 0) // when true, the frame does have a west neighbour
					f.setWestNeighbour(frameList.get(c - 1).ID)

				if (c / PROBLEM_SIZE != 0) // when true, the frame does have a north neighbour
					f.setNorthNeighbour(frameList.get(c - PROBLEM_SIZE).ID)

				if (c + PROBLEM_SIZE < (PROBLEM_SIZE * PROBLEM_SIZE)) // when true, the frame does have a south neighbour
					f.setSouthNeighbour(frameList.get(c + PROBLEM_SIZE).ID)

				if (c % PROBLEM_SIZE != (PROBLEM_SIZE - 1)) // when true, the frame does have a east neighbour
					f.setEastNeighbour(frameList.get(c + 1).ID)
				
				c++
			}
			
			// Shuffle tile positions
			var startingTiles : List<Integer> = new ArrayList
			
			for (var i = 1; i < Math.pow(PROBLEM_SIZE, 2); i++)
				startingTiles.add(i)

			Collections.shuffle(startingTiles)

			info("Starting positions " + startingTiles)
			
			// Spawn tile agents (num tile/UUID frame/num frame/ problem size)
			for (var i = 0; i < Math.pow(PROBLEM_SIZE, 2) - 1; i++)
				spawn(TileAgent, #[startingTiles.get(i), frameList.get(i).ID, i, PROBLEM_SIZE])
			
			// Spawn blank tile
			spawn(EmptyTileAgent)			
		}
	}
	
	on TileSet {
		
		nbTileSet++
		
		if (occurrence.tile !== null) // DO NOT REMOVE THIS TEST
			tileList.add(occurrence.tile)

		if (nbTileSet === Math.round(Math.pow(PROBLEM_SIZE, 2))) {
			info("Every single TileAgent is set. Setting token priority lists.")

			// Ordering initial list by numTile to avoid later more complicated computation
			Collections.sort(tileList)[a, b|a.numTile - b.numTile]
					
			var tempList = new ArrayList<TileAgent>()
							
			// Setting token priority lists
			for (var i = 1; i < PROBLEM_SIZE; i++)
				tokenPriorityList.add(new ArrayList())
			
			// Put the tile in the right tokenPriority list
			for (t : tileList)
				tokenPriorityList.get(t.getTokenPriority).add(t)

			// Modify the sorting of each list
			for (l : tokenPriorityList)		
			{
				for (var tilesToSwitch = (l.size / 2) + 1; tilesToSwitch > 0 ; tilesToSwitch--)
				{
					tempList.add(l.get(0))
					l.remove(0)
				}
				
				while (!tempList.empty)
				{
					l.add(0, tempList.get(0))
					tempList.remove(0)
				}
				
				//for (t : l)
				//	info(t.numTile)
			}

			info("TokenPriorityList data set up.")
			
			// Sending the token
			wake(new TokenReleased)
		}
	}

	on TokenReleased {
		
		// Looking for the first unsatisfied tile on the first priority list
		do {
			for (t : tokenPriorityList.get(0))
			{
				if (!t.isHappy)
				{
					emit(new TokenReceived(), Scopes.addresses(defaultSpace.getAddress(t.ID)))
					return
				}
			}
			
			tokenPriorityList.remove(0)
			
			// It is over
			if (tokenPriorityList.empty)
				return
			// Else ... get to the next list by looping
			
		} while (!tokenPriorityList.empty)
	}



	/* PROBABLEMENT DEJA OBSOLETE

	on FrameSatisfied {

		if (!occurrence.satisfied)
			nbFrameSatisfied--
		else
			if (nbFrameSatisfied === Math.round(Math.pow(PROBLEM_SIZE, 2)) - 1)
			{	
				info("Checking satisfaction of every Frame.") // in case of false positive due to synchronization issues
				// todo
				
				if (1 === 1)
				{
					info("Every Frame satisfied. Game completed.")
					emit(new GameCompleted)
				
				}
			}
	}*/

	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}
}
