
package fr.utbm.ia54.Agent

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Lifecycle
import fr.utbm.ia54.Event.GameSet
import fr.utbm.ia54.Event.FrameSatisfied
import io.sarl.core.DefaultContextInteractions
import java.util.ArrayList
import java.util.List
import java.util.Collections
import fr.utbm.ia54.Event.FrameSet
import fr.utbm.ia54.Event.GameCompleted
import fr.utbm.ia54.Event.TileSet
import fr.utbm.ia54.Event.TokenReceived
import io.sarl.util.Scopes
import fr.utbm.ia54.Event.TokenReleased
import io.sarl.core.Behaviors
import fr.utbm.ia54.gui.TaquinFxViewerController
import fr.utbm.taquin.events.ActionUI
import java.util.UUID
import fr.utbm.ia54.Class.CoordPair
import fr.utbm.ia54.Class.InfosFrame

enum position {
	NORTH,
	SOUTH,
	EAST,
	WEST
	;
}
 
agent BoardGameAgent {
	uses Logging, Lifecycle, DefaultContextInteractions, Behaviors
	
	var PROBLEM_SIZE = 3
	var nbFrameSet = 0
	var nbTileSet = 0
	var frameList = new ArrayList<FrameAgent>()
	
	// TKS
	var frameUUIDList = new ArrayList<UUID>()
	var listCoordPairsOfFrames = new ArrayList<CoordPair>()
	
	var openListOfFrames = new ArrayList<InfosFrame>()
	var closedListOfFrames = new ArrayList<InfosFrame>()
	
	// use the Class InfosFrame instead of these var
//	var listOfCostG = new ArrayList<Integer>() // from beginning to current
//	var listOfCostH = new ArrayList<Integer>() // from current to arrival
//	var listOfCostF = new ArrayList<Integer>() // sum of the previous (memorize)
	
	var tileList = new ArrayList<TileAgent>()
	var tokenPriorityList = new ArrayList<ArrayList<TileAgent>>()

	var ctrl : TaquinFxViewerController

	
	on Initialize {

		loggingName = 'BoardGameAgent'

		PROBLEM_SIZE = occurrence.parameters.get(0) as Integer
		ctrl = occurrence.parameters.get(1) as TaquinFxViewerController

		val numFrameList : List<Integer> = new ArrayList // TKS: redondance de nom --> changement

		for (var i = 1; i <= Math.pow(PROBLEM_SIZE, 2); i++)
			numFrameList.add(i) // TKS

		for (var i = 0; i <= Math.pow(PROBLEM_SIZE, 2) - 1; i++) { // spawn FrameAgent(num,row,col,size)
		 	// TKS
			frameUUIDList.add(spawn(FrameAgent, #[numFrameList.get(i), i / PROBLEM_SIZE, i % PROBLEM_SIZE, PROBLEM_SIZE])) // get UUID of the frameAgent
			listCoordPairsOfFrames.add(new CoordPair((i / PROBLEM_SIZE), (i % PROBLEM_SIZE)))
			
			/*listOfCostG.add(-1)
			listOfCostH.add(-1)
			listOfCostF.add(-1)*/
		}
		
		info("Board game has been set.")		
	}
 
	on FrameSet {
		
		nbFrameSet++

		frameList.add(occurrence.frame)

		// ouais c'est bon on est tous là !
		if (nbFrameSet === Math.round(Math.pow(PROBLEM_SIZE, 2)))
		{
			info("Every single FrameAgent is set. Spawning every single TileAgent.")

			// Ordering initial list of frame in order to set neighbours
			Collections.sort(frameList)[a, b|a.numFrame - b.numFrame]
			
			// Setting neighbours
			var c = 0
			for (f : frameList)
			{
				if (c % PROBLEM_SIZE != 0) // when true, the frame does have a west neighbour
					f.setWestNeighbour(frameList.get(c - 1).ID)

				if (c / PROBLEM_SIZE != 0) // when true, the frame does have a north neighbour
					f.setNorthNeighbour(frameList.get(c - PROBLEM_SIZE).ID)

				if (c + PROBLEM_SIZE < (PROBLEM_SIZE * PROBLEM_SIZE)) // when true, the frame does have a south neighbour
					f.setSouthNeighbour(frameList.get(c + PROBLEM_SIZE).ID)

				if (c % PROBLEM_SIZE != (PROBLEM_SIZE - 1)) // when true, the frame does have a east neighbour
					f.setEastNeighbour(frameList.get(c + 1).ID)
				
				c++
			}
			
			// Shuffle tile positions
			var startingTiles : List<Integer> = new ArrayList
			
			for (var i = 1; i < Math.pow(PROBLEM_SIZE, 2); i++)
				startingTiles.add(i)

			Collections.shuffle(startingTiles)

			info("Starting positions " + startingTiles)

			// COMMUNICATION AVEC UI
			// emit(new InitDone(startingTiles))
			ctrl.monTest(startingTiles);
			
			// Spawn tile agents (num tile/UUID frame/num frame/ problem size)
			for (var i = 0; i < Math.pow(PROBLEM_SIZE, 2) - 1; i++)
				spawn(TileAgent, #[startingTiles.get(i), frameList.get(i).ID, i, PROBLEM_SIZE])
			
			// Spawn blank tile
			spawn(EmptyTileAgent)			
		}
	}
	
	on TileSet {
		
		nbTileSet++
		
		if (occurrence.tile !== null) // DO NOT REMOVE THIS TEST
			tileList.add(occurrence.tile)

		if (nbTileSet === Math.round(Math.pow(PROBLEM_SIZE, 2))) {
			info("Every single TileAgent is set. Setting token priority lists.")

			// Ordering initial list by numTile to avoid later more complicated computation
			Collections.sort(tileList)[a, b|a.numTile - b.numTile]
					
			var tempList = new ArrayList<TileAgent>()
							
			// Setting token priority lists
			for (var i = 1; i < PROBLEM_SIZE; i++)
				tokenPriorityList.add(new ArrayList())
			
			// Put the tile in the right tokenPriority list
			for (t : tileList)
				tokenPriorityList.get(t.getTokenPriority).add(t)

			// Modify the sorting of each list
			for (l : tokenPriorityList)		
			{
				for (var tilesToSwitch = (l.size / 2) + 1; tilesToSwitch > 0 ; tilesToSwitch--)
				{
					tempList.add(l.get(0))
					l.remove(0)
				}
				
				while (!tempList.empty)
				{
					l.add(0, tempList.get(0))
					tempList.remove(0)
				}
				
				//for (t : l)
				//	info(t.numTile)
			}

			info("TokenPriorityList data set up.")
			
			// Sending the token
			wake(new TokenReleased)

			// Wait until every agent is spawned
			info("*************** nbFrameSet=" + nbFrameSet+" /nbTileSet="+nbTileSet)
			info("!!!!!!!!!!!!! BEGIN TEST OF the A-star ALGORITHM !!!!!!!!!!!!!")
			findPath
		}
	}

	on TokenReleased {
		
		// Looking for the first unsatisfied tile on the first priority list
		do {
			for (t : tokenPriorityList.get(0))
			{
				if (!t.isHappy)
				{
					emit(new TokenReceived(), Scopes.addresses(defaultSpace.getAddress(t.ID)))
					return
				}
			}
			
			tokenPriorityList.remove(0)
			
			// It is over
			if (tokenPriorityList.empty)
				return
			// Else ... get to the next list by looping
			
		} while (!tokenPriorityList.empty)
	}

	on ActionUI {
		info("JE VAIS FAIRE CHANGER COULEUR.")
		ctrl.setColor("rouge", occurrence.target)
	}
	
	/** 
	 * calculate the euclidean distance between 2 frames
	 * @params a,b : 2 FrameAgent
	 * @return int: square euclidean distance
	 */
	 // TKS
	def distEuclidian(a : FrameAgent, b : FrameAgent) : int {
		return ((a.XRow - b.XRow) * (a.XRow - b.XRow) + (a.YCol - b.YCol) * (a.YCol - b.YCol))
	}
	
	/** 
	 * determinate if the frame is in the list
	 * @params pair, listOfFrames : CoordPair & ArrayList<InfosFrame>
	 * @return boolean: true if the CoordPair correspond to coords of an FrameAgent in the list
	 */
	 // TKS
	def isInFrameList(pair : CoordPair, listOfFrames : ArrayList<InfosFrame>) : boolean {
		for (fa : listOfFrames) {
			 if(pair.equals(fa.coordsCurrentFrame))
			 	return true
		}
		return false
	}
	
	/** 
	 * add the neighbour's frames of the current frame
	 * @params currentFrame: the current FrameAgent
	 */
	 // TKS
	def addNeighbourFrames(currentFrame : FrameAgent)
	{			
		// the north's frame exists======================================================================================================================
		if (currentFrame.northNeighbour != null) {
			info("+++++NORTH exists")
			var index = frameUUIDList.indexOf(currentFrame.northNeighbour)

			// TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
			if (!frameList.get(index).isSatisfied) {

				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var newCoords = frameList.get(index).coordPair
				info("+++++NORTH) coordNeighbour=" + coordNeighbour.toString)

				// if doesn't exist in the closed list
				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {
					info("+++++NORTH) not in closedList")

					// the treated frame (stock the infos)
					var infosFrame = new InfosFrame(currentFrame.northNeighbour, coordNeighbour)

					// costG of north's neighbour: cost of previous + distance to previous
					var indexForClosedList = -1
					for (iterator : closedListOfFrames) {
						indexForClosedList++
						if (iterator.uuidCurrentFrame == currentFrame.ID)
							break
					}

					info("+++++NORTH) indexForClosedList=" + indexForClosedList)

					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
						distEuclidian(frameList.get(index), currentFrame)

					info("+++++NORTH) infosFrame.costG=" + infosFrame.costG)
					info("+++++NORTH) infosFrame.coords=" + infosFrame.coordsCurrentFrame.toString)

					// TODO: ATTENTION ! DOIT ETRE LA FRAME POSSEDANT LA BLANKTILE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					var arrivalFrame = frameList.get(((PROBLEM_SIZE * PROBLEM_SIZE) - 1)) // TKS: modify with the frame which has the blankTile
					// costH of north's neighbour: it to arrival
					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
					infosFrame.costF = infosFrame.costG + infosFrame.costH
					info("+++++NORTH) infosFrame.costH=" + infosFrame.costH + " /infosFrame.costF=" + infosFrame.costF)

					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
					infosFrame.uuidPreviousFrame = currentFrame.ID
					infosFrame.coordsPreviousFrame = currentFrame.coordPair
					info("+++++NORTH) infosFrame.coordsPreviousFrame.coords=" + infosFrame.coordsPreviousFrame.toString)

					var indexForOpenList = -1
					for (iterator : openListOfFrames) {
						indexForOpenList++
						if (iterator.uuidCurrentFrame == currentFrame.northNeighbour)
							break
					}

					info("+++++NORTH) indexForOpenList=" + indexForOpenList)

					// if already exists: compare the cost
					if (isInFrameList(coordNeighbour, openListOfFrames)) {

						info("+++++NORTH) already exists in openList")

						// only if the new path is shorter: update it ELSE do nothing
						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF) {
							info("+++++NORTH) newPath is shorter: UPDATE it")
							openListOfFrames.set(indexForOpenList, infosFrame)
						}
					} // the treated frame (north's frame) is not in the openList yet: add it
					else {
						openListOfFrames.add(infosFrame)
						info("+++++NORTH) doesn't exists yet in openList: ADD it /openListOfFrames.size=" + openListOfFrames.size)
					}
				}
			}
		}

		// the south's frame exists======================================================================================================================
		if (currentFrame.southNeighbour != null) {
			info("+++++SOUTH exists")
			var index = frameUUIDList.indexOf(currentFrame.southNeighbour)

			// TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
			if (!frameList.get(index).isSatisfied) {

				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var newCoords = frameList.get(index).coordPair
				info("+++++SOUTH) coordNeighbour=" + coordNeighbour.toString)

				// if doesn't exist in the closed list
				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {
					info("+++++SOUTH) not in closedList")

					// the treated frame (stock the infos)
					var infosFrame = new InfosFrame(currentFrame.southNeighbour, coordNeighbour)

					// costG of south's neighbour: cost of previous + distance to previous
					var indexForClosedList = -1
					for (iterator : closedListOfFrames) {
						indexForClosedList++
						if (iterator.uuidCurrentFrame == currentFrame.ID)
							break
					}

					info("+++++SOUTH) indexForClosedList=" + indexForClosedList)

					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
						distEuclidian(frameList.get(index), currentFrame)

					info("+++++SOUTH) infosFrame.costG=" + infosFrame.costG)
					info("+++++SOUTH) infosFrame.coords=" + infosFrame.coordsCurrentFrame.toString)

					// TODO: ATTENTION ! DOIT ETRE LA FRAME POSSEDANT LA BLANKTILE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					var arrivalFrame = frameList.get(((PROBLEM_SIZE * PROBLEM_SIZE) - 1)) // TKS: modify with the frame which has the blankTile
					// costH of south's neighbour: it to arrival
					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
					infosFrame.costF = infosFrame.costG + infosFrame.costH
					info("+++++SOUTH) infosFrame.costH=" + infosFrame.costH + " /infosFrame.costF=" + infosFrame.costF)

					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
					infosFrame.uuidPreviousFrame = currentFrame.ID
					infosFrame.coordsPreviousFrame = currentFrame.coordPair
					info("+++++SOUTH) infosFrame.coordsPreviousFrame.coords=" + infosFrame.coordsPreviousFrame.toString)

					var indexForOpenList = -1
					for (iterator : openListOfFrames) {
						indexForOpenList++
						if (iterator.uuidCurrentFrame == currentFrame.southNeighbour)
							break
					}

					info("+++++SOUTH) indexForOpenList=" + indexForOpenList)

					// if already exists: compare the cost
					if (isInFrameList(coordNeighbour, openListOfFrames)) {

						info("+++++SOUTH) already exists in openList")

						// only if the new path is shorter: update it ELSE do nothing
						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF) {
							info("+++++SOUTH) newPath is shorter: UPDATE it")
							openListOfFrames.set(indexForOpenList, infosFrame)
						}
					} // the treated frame (south's frame) is not in the openList yet: add it
					else {
						openListOfFrames.add(infosFrame)
						info("+++++SOUTH) doesn't exists yet in openList: ADD it /openListOfFrames.size=" + openListOfFrames.size)
					}
				}
			}
		}

		// the east's frame exists======================================================================================================================
		if (currentFrame.eastNeighbour != null) {
			info("+++++EAST exists")
			var index = frameUUIDList.indexOf(currentFrame.eastNeighbour)

			// TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
			if (!frameList.get(index).isSatisfied) {

				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var newCoords = frameList.get(index).coordPair
				info("+++++EAST) coordNeighbour=" + coordNeighbour.toString)
												
				// if doesn't exist in the closed list
				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {
					info("+++++EAST) not in closedList")

					// the treated frame (stock the infos)
					var infosFrame = new InfosFrame(currentFrame.eastNeighbour, coordNeighbour)

					// costG of east's neighbour: cost of previous + distance to previous
					var indexForClosedList = -1
					for (iterator : closedListOfFrames) {
						indexForClosedList++
						if (iterator.uuidCurrentFrame == currentFrame.ID)
							break
					}

					info("+++++EAST) indexForClosedList=" + indexForClosedList)

					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
						distEuclidian(frameList.get(index), currentFrame)

					info("+++++EAST) infosFrame.costG=" + infosFrame.costG)
					info("+++++EAST) infosFrame.coords=" + infosFrame.coordsCurrentFrame.toString)

					// TODO: ATTENTION ! DOIT ETRE LA FRAME POSSEDANT LA BLANKTILE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					var arrivalFrame = frameList.get(((PROBLEM_SIZE * PROBLEM_SIZE) - 1)) // TKS: modify with the frame which has the blankTile
					// costH of east's neighbour: it to arrival
					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
					infosFrame.costF = infosFrame.costG + infosFrame.costH
					info("+++++EAST) infosFrame.costH=" + infosFrame.costH + " /infosFrame.costF=" + infosFrame.costF)

					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
					infosFrame.uuidPreviousFrame = currentFrame.ID
					infosFrame.coordsPreviousFrame = currentFrame.coordPair
					info("+++++EAST) infosFrame.coordsPreviousFrame.coords=" + infosFrame.coordsPreviousFrame.toString)

					var indexForOpenList = -1
					for (iterator : openListOfFrames) {
						indexForOpenList++
						if (iterator.uuidCurrentFrame == currentFrame.eastNeighbour)
							break
					}

					info("+++++EAST) indexForOpenList=" + indexForOpenList)

					// if already exists: compare the cost
					if (isInFrameList(coordNeighbour, openListOfFrames)) {

						info("+++++EAST) already exists in openList")

						// only if the new path is shorter: update it ELSE do nothing
						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF) {
							info("+++++EAST) newPath is shorter: UPDATE it")
							openListOfFrames.set(indexForOpenList, infosFrame)
						}
					} // the treated frame (east's frame) is not in the openList yet: add it
					else {
						openListOfFrames.add(infosFrame)
						info("+++++EAST) doesn't exists yet in openList: ADD it /openListOfFrames.size=" + openListOfFrames.size)
					}
				}
			}
		}

		// the west's frame exists======================================================================================================================
		if (currentFrame.westNeighbour != null) {
			info("+++++WEST exists")
			var index = frameUUIDList.indexOf(currentFrame.westNeighbour)

			//TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
			if (!frameList.get(index).isSatisfied) {

				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var newCoords = frameList.get(index).coordPair
				info("+++++WEST) coordNeighbour=" + coordNeighbour.toString)
												
				// if doesn't exist in the closed list
				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {
					info("+++++WEST) not in closedList")

					// the treated frame (stock the infos)
					var infosFrame = new InfosFrame(currentFrame.westNeighbour, coordNeighbour)

					// costG of west's neighbour: cost of previous + distance to previous
					var indexForClosedList = -1
					for (iterator : closedListOfFrames) {
						indexForClosedList++
						if (iterator.uuidCurrentFrame == currentFrame.ID)
							break
					}

					info("+++++WEST) indexForClosedList=" + indexForClosedList)
					
					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
						distEuclidian(frameList.get(index), currentFrame)

					info("+++++WEST) infosFrame.costG=" + infosFrame.costG)
					info("+++++WEST) infosFrame.coords=" + infosFrame.coordsCurrentFrame.toString)

					// TODO: ATTENTION ! DOIT ETRE LA FRAME POSSEDANT LA BLANKTILE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					var arrivalFrame = frameList.get(((PROBLEM_SIZE * PROBLEM_SIZE) - 1)) // TKS: modify with the frame which has the blankTile
					// costH of west's neighbour: it to arrival
					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
					infosFrame.costF = infosFrame.costG + infosFrame.costH
					info("+++++WEST) infosFrame.costH=" + infosFrame.costH+" /infosFrame.costF="+infosFrame.costF)

					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
					infosFrame.uuidPreviousFrame = currentFrame.ID
					infosFrame.coordsPreviousFrame = currentFrame.coordPair
					info("+++++WEST) infosFrame.coordsPreviousFrame.coords=" + infosFrame.coordsPreviousFrame.toString)

					var indexForOpenList = -1
					for (iterator : openListOfFrames) {
						indexForOpenList++
						if (iterator.uuidCurrentFrame == currentFrame.westNeighbour)
							break
					}
					
					info("+++++WEST) indexForOpenList=" + indexForOpenList)

					// if already exists: compare the cost
					if (isInFrameList(coordNeighbour, openListOfFrames)) {
					
						info("+++++WEST) already exists in openList")

						// only if the new path is shorter: update it ELSE do nothing
						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF) {
							info("+++++WEST) newPath is shorter: UPDATE it")
							openListOfFrames.set(indexForOpenList, infosFrame)
						}
					} // the treated frame (west's frame) is not in the openList yet: add it
					else {
						openListOfFrames.add(infosFrame)
						info("+++++WEST) doesn't exists yet in openList: ADD it /openListOfFrames.size=" + openListOfFrames.size)
					}
				}
			}
		}
	} // end of addNeighbourFrames()
	
	
	/** 
	 * get the frame with best cost from the frameList
	 * @param listFrames: list of InfosFrame
	 * @return InfosFrame: the infosFrame with the best (lower) cost OR null if the list is empty
	 */
	 // TKS
def getBestFrame(listFrames : ArrayList<InfosFrame>) : InfosFrame {
	info("////////////////////////getBestFrames(): listFrames.size"+listFrames.size)
		if(!listFrames.empty){ // the list is not empty
			var costF = listFrames.get(0).costF
			var infoFrame = listFrames.get(0)
			
			for(frame : listFrames){
				info("////////////////////////getBestFrames(): frame.coords=" + frame.coordsCurrentFrame.toString)
				info("////////////////////////getBestFrames(): frame.costGHF=" + frame.toStringGHF)
				if(frame.costF < costF){ // get the lower cost in the list
					info("////////////////////////getBestFrames(): get a better one (lower)")
					costF = frame.costF
					infoFrame = frame
				}
			}
				
			info("////////////////////////getBestFrames(): return " + infoFrame.coordsCurrentFrame.toString)
			return infoFrame
		}
		
		info("////////////////////////getBestFrames(): return NULL")
		return null		
	}
	
	/** 
	 * add the InfosFrame in the closedList and remove it from the openList
	 * @param coords: CoordPair of the frame to manipulate
	 */
	 // TKS
	def addInClosedList(coords : CoordPair){
		var index = -1
		for(ite : openListOfFrames){
			index++
			if(ite.coordsCurrentFrame.equals(coords)){ // found it in the openList
				closedListOfFrames.add(ite) 	// add in the closedList
				break
			}				
		}
		openListOfFrames.remove(index) // remove it from the openList
	}
	
	// TKS
	def findPath{
		
		// the arrival frame (on wich there is the blankTile) is the last one in the closedList
		//var tmpFrame = closedListOfFrames.get(closedListOfFrames.size-1) // take the last one
		
		// TKS: TEST ===================================
		
		info("--------------BEGIN function findPath--------------")

		info("######## 0)nbFrameSet=" + nbFrameSet)
		info("######## 0)lastNumber=" + ((PROBLEM_SIZE * PROBLEM_SIZE) - 1))
		val beginningFrame = new InfosFrame(frameUUIDList.get(1), listCoordPairsOfFrames.get(8)) // TODO: CHANGE WITH THE FRAME ON WHICH THE FILE HAS THE TOKEN
		val arrivalFrame = new InfosFrame(frameUUIDList.get((PROBLEM_SIZE * PROBLEM_SIZE) - 1),listCoordPairsOfFrames.get((PROBLEM_SIZE * PROBLEM_SIZE) - 1))
		var currentFrame = beginningFrame
		
		openListOfFrames.add(beginningFrame)
		info("######## 1)openListOfFrames.size=" + openListOfFrames.size)
		info("######## 1)arrivalFrame.coords=" + arrivalFrame.coordsCurrentFrame.toString)
		
		addInClosedList(beginningFrame.coordsCurrentFrame)
		info("######## 2)openListOfFrames.size=" + openListOfFrames.size)
		info("######## 2)closedListOfFrames.size=" + closedListOfFrames.size)
		
		// get the frame with the index of FrameList
		var indexOfFrameList = -1
		for(ite : frameList){
			indexOfFrameList++
			if(ite.coordPair.equals(beginningFrame.coordsCurrentFrame))
				break
		}
		
		info("######## 3)frameList=" + frameList.size)
		info("######## 3)indexOfFrameList=" + indexOfFrameList)
		
		// add the neighbours in the openList
		addNeighbourFrames(frameList.get(indexOfFrameList))
		
		// until the destination has been reached && openList is empty
		while(!currentFrame.coordsCurrentFrame.equals(arrivalFrame.coordsCurrentFrame) && !openListOfFrames.empty){
			info("######## 4)while++")
			currentFrame = getBestFrame(openListOfFrames)
			info("######## 4)bestFrame="+currentFrame.coordsCurrentFrame.toString+" /openListOfFrames.size="+openListOfFrames.size)
			addInClosedList(currentFrame.coordsCurrentFrame)
			info("######## 4)addInClosedList-->closedListOfFrames.size=" + closedListOfFrames.size)		
		}
		
		// if destination is reached : build the path in the opposite direction of the chain of aggression
		// TODO: retrouver_chemin()
		
		// test: afficher la closedList
		var i = -1;
		for (ite : closedListOfFrames) {
			i++
			info("closed["+i+"]=" + ite.coordsCurrentFrame.toString)
		}

		info("--------------END function findPath--------------")
		//==============================================
	}

	// TODO: determinate the frame (BeginningFrame) on wich the currentTile wants to go (FIRST aggression of the chain)
	// THEN 
	// TODO: implement the scheduling of the algorithm A*, for using it with the BeginningFrame (tileX who wants to move) and the ArrivalFrame(blankTile)

	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}
}
