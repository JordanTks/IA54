/** 
 * 
 */
package fr.utbm.ia54.Agent


import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.InnerContextAccess
import fr.utbm.ia54.Event.Assault
import fr.utbm.ia54.Event.FrameSet
import java.util.UUID
import fr.utbm.ia54.Class.CoordPair
import fr.utbm.ia54.Event.PathCalculation
import fr.utbm.ia54.Event.EndAgent
import fr.utbm.ia54.Event.PathFound
import io.sarl.util.Scopes
import fr.utbm.ia54.Event.AskNeighbourSatisfaction
import java.util.LinkedHashMap
import fr.utbm.ia54.Event.ResponseNeighbourSatisfaction
import fr.utbm.ia54.Event.FindPathWithAstarAlgo
import io.sarl.core.Behaviors
import fr.utbm.ia54.Event.SafetyWait
import java.util.ArrayList
import fr.utbm.ia54.Event.PathCalculationTimeOut
import fr.utbm.ia54.Event.TokenReleased
import java.util.Collections
import fr.utbm.ia54.Event.UpdateProblemInformations
import fr.utbm.ia54.Event.AcknowledgmentDataUpdated
import fr.utbm.ia54.Event.UpdateGUI
import fr.utbm.ia54.Enum.Direction

/** 
 * @author Jordan
 * 
 */
agent FrameAgent {
	uses Logging, Lifecycle, Schedules, InnerContextAccess, DefaultContextInteractions, Behaviors

	// PathCalculation
	val TIMEOUT = 150
	//var lastInitiatedAssault = 0l
	var previousPathCalculationId : long
	var previousPathCalculationJumpValue : int
	var previousPathDidMoveHappyTiles : boolean
	var bestPath : ArrayList<FrameAgent>
	var bestForcedPath : ArrayList<FrameAgent>

	// Swapping Tiles
	var nbAck : int

	// FrameAgent state
	var isSatisfied = false
	var isBlocked = false // the tile which with it is paired will never move
	var didMyTileMateHaveTheToken = false
	
	// FrameAgent knowledge
	var nbNeighbours : int
	var northNeighbour : UUID
	var eastNeighbour : UUID
	var southNeighbour : UUID
	var westNeighbour : UUID

	var hostedTile : UUID
	var hostedNumTile : int
	
	// Temporary knowledge
	var neighbourSatisfaction = new LinkedHashMap<Direction, Boolean>()
	
	var ready = false 
	var dimension = -1

	var idNum = -1
  	var idNumFromZero : int
  
	var xRow = -1
	var yCol = -1
	var coordPair : CoordPair // coords (Xrow,Ycol) of the frame
	var costG = 0 // from beginning to current
	var costH = 0 // from current to arrival
	var costF = 0 // sum of the previous (memorize)
	var uuidPreviousFrame : UUID
	var coordsXYPreviousFrame : CoordPair

	on Initialize { 
		
		idNum = occurrence.parameters.get(0) as Integer
		//idNumFromZero = idNum - 1

		xRow = occurrence.parameters.get(1) as Integer
		yCol = occurrence.parameters.get(2) as Integer
		coordPair = new CoordPair(xRow,yCol)
		
		nbNeighbours = 0
		northNeighbour = null
		eastNeighbour = null
		southNeighbour = null
		westNeighbour = null

		loggingName = 'FrameAgent' + idNum

		in (1000) [wake(new SafetyWait())]
		//emit(new FrameSet(this))
		
		// info("DEBUGG : Agent is set up.")
	}
	
	// Attempt at avoiding null pointer exceptions
	on SafetyWait {
		emit(new FrameSet(this))
	}

	// Forwards the question to the neighbours
	on AskNeighbourSatisfaction [!isAsked] {

		// info("DEBUGG : AskNeighbourSatisfaction !isAsked")
 
		// Clearing answers map
		neighbourSatisfaction.clear

		// Asking satisfaction of the two neighbour frames
		if (occurrence.north)
			emit(new AskNeighbourSatisfaction(true, Direction.NORTH), Scopes.identifiers(northNeighbour))
		else
			emit(new AskNeighbourSatisfaction(true, Direction.SOUTH), Scopes.identifiers(southNeighbour))

		if (occurrence.west)
			emit(new AskNeighbourSatisfaction(true, Direction.WEST), Scopes.identifiers(westNeighbour))
		else
			emit(new AskNeighbourSatisfaction(true, Direction.EAST), Scopes.identifiers(eastNeighbour))
	}

	// Get asked and have to answer back
	on AskNeighbourSatisfaction [isAsked] {

		// info("DEBUGG : AskNeighbourSatisfaction isAsked")
		
		// Answers back to the event transmitter
		emit(new ResponseNeighbourSatisfaction(isSatisfied, occurrence.direction), Scopes.identifiers(occurrence.source.UUID))
	}

	// Receive a response from a neighbour
	on ResponseNeighbourSatisfaction {

		info("DEBUGG : ResponseNeighbourSatisfaction [frame] : direction " + occurrence.direction + "    isSatisfied " + occurrence.isSatisfied)

		// Store answer in map
		neighbourSatisfaction.put(occurrence.direction, occurrence.isSatisfied)

		// We check how much data we collected
		if (neighbourSatisfaction.size >= 2)
		{
			// We have two answers, therefore we can send back the results to the tile
			emit(new ResponseNeighbourSatisfaction(neighbourSatisfaction), Scopes.identifiers(hostedTile))
			// We risk clearing the list before the event is received -> null pointer exception ?
			// neighbourSatisfaction.clear
		}
	}

	// The assault must be forwarded to the right frame
	on Assault [!isAttacked] {

		// info("DEBUGG : I FORWARD ASSAULT !")
		
		// Remove potential data from former path calculations
		bestPath = null
		bestForcedPath = null
		
		// Assault the neighbour it was asked to
		if (occurrence.direction === Direction.NORTH)
			emit(new Assault(Direction.SOUTH, true), Scopes.identifiers(northNeighbour))
		else if (occurrence.direction === Direction.SOUTH)
			emit(new Assault(Direction.NORTH, true), Scopes.identifiers(southNeighbour))
		else if (occurrence.direction === Direction.WEST)
			emit(new Assault(Direction.EAST, true), Scopes.identifiers(westNeighbour))
		else if (occurrence.direction === Direction.EAST)
			emit(new Assault(Direction.WEST, true), Scopes.identifiers(eastNeighbour))
	}

	// The frame is being assaulted
	on Assault [isAttacked] {

		//error("=========================================== DEBUGG : I GOT ATTACKED ! emit FINDPATH! /hostedNumTile=" + hostedNumTile)
		info("DEBUGG : I GOT ATTACKED !")

		// I have to run away by finding a path between me and the empty tile
		
		// if (resolution par point de vue global)
		//emit(new FindPathWithAstarAlgo(ID))
		// else if (resolution distribuee)
		wake(new PathCalculation(System.currentTimeMillis, occurrence.source.UUID, occurrence.direction, System.currentTimeMillis, false, 0, new ArrayList<FrameAgent>))
		in (TIMEOUT) [emit(new PathCalculationTimeOut(), Scopes.addresses(defaultSpace.getAddress(occurrence.source.UUID)))]
	}
	
	// PathCalculation by spreading message
	on PathCalculation {
		
		// Discard message if timeout
		if (System.currentTimeMillis - TIMEOUT > occurrence.timeStamp)
			return;
		
		// Discard message if I am the one who initiated the attack
		if (occurrence.requestOrigin == this.ID)
			return;
		
		// Check already forwarded path calculations to avoid spreading useless events
		// This implementation does NOT work if there are multiple different path calculations at once
		// -> The following would have to be modified
		
		// If the previous request was for the same path calculation ...
		if (previousPathCalculationId === occurrence.requestId)
		{
			// If it is a good path ...
			if (!occurrence.forcePath)
			{
				// If I already have a good path ...
				if (!previousPathDidMoveHappyTiles)
				{
					// If I have a better or even path
					if (previousPathCalculationJumpValue <= occurrence.jumpCount)
					{
						// ... it is useless to spread the message
						return;	
					}	
				}
			}
			else // If it is a bad path ...
			{
				// If I already have a good path ...
				if (!previousPathDidMoveHappyTiles)
				{
					// ... it is useless to spread the message
					return;
				}
				else // If I already have a bad path ...
				{
					// If I have a better path
					if (previousPathCalculationJumpValue < occurrence.jumpCount) {
						// ... it is useless to spread the message
						return;
					}
				}
			}
		}
		
		// Setting the values for the next PathCalculation received
		previousPathCalculationId = occurrence.requestId
		previousPathCalculationJumpValue = occurrence.jumpCount
		previousPathDidMoveHappyTiles = occurrence.forcePath
		
		// Adding itself to the path
		var p : ArrayList<FrameAgent>
		//p = occurrence.path.clone as ArrayList <FrameAgent>
		p = new ArrayList<FrameAgent>
		p.addAll(occurrence.path)
		p.add(this)
		
		// If we host the blank tile ...
		if (hostedNumTile === 0)
		{
			// ... we send the path that was found
			emit(new PathFound(occurrence.requestId, occurrence.forcePath, occurrence.jumpCount, p),
				Scopes.addresses(defaultSpace.getAddress(occurrence.requestOrigin)))
			// We avoid spreading more useless PathCalculation
			return
		}
		
		var forcingAPath = false
		
		// If we were forcing a path before, we have to forward this information
		if (occurrence.forcePath)
		{
			forcingAPath = true
		}
		// If we did not force a path yet, we check we are not doing it right now
		else
		{
			if (isSatisfied)
				forcingAPath = true
		}
		
		// I usually am not disturbed when this is true, EXCEPT, when a tile tries to get in a corner
		if (didMyTileMateHaveTheToken)
		{
			// To help the tile get in the corner we have to behave a little bit differently
			// We have to flee by going to the opposite side of the aggression, whenever possible
			
			if (occurrence.provenanceDirection === Direction.NORTH && southNeighbour !== null)
			{
				emit(new PathCalculation(occurrence.requestId, occurrence.requestOrigin, Direction.NORTH,
					occurrence.timeStamp, forcingAPath, occurrence.jumpCount + 1, p),
					Scopes.addresses(defaultSpace.getAddress(this.southNeighbour)))

				// If it is possible, then we do not try to find a path in other directions.
				return;
			}

			if (occurrence.provenanceDirection === Direction.SOUTH && northNeighbour !== null) {
				emit(
					new PathCalculation(occurrence.requestId, occurrence.requestOrigin, Direction.SOUTH,
					occurrence.timeStamp, forcingAPath, occurrence.jumpCount + 1, p),
					Scopes.addresses(defaultSpace.getAddress(this.northNeighbour)))

				// If it is possible, then we do not try to find a path in other directions.
				return;
			}

			if (occurrence.provenanceDirection === Direction.EAST && westNeighbour !== null) {
				emit(
					new PathCalculation(occurrence.requestId, occurrence.requestOrigin, Direction.EAST,
					occurrence.timeStamp, forcingAPath, occurrence.jumpCount + 1, p),
					Scopes.addresses(defaultSpace.getAddress(this.westNeighbour)))

				// If it is possible, then we do not try to find a path in other directions.
				return;
			}

			if (occurrence.provenanceDirection === Direction.WEST && eastNeighbour !== null) {
				emit(
					new PathCalculation(occurrence.requestId, occurrence.requestOrigin, Direction.WEST,
					occurrence.timeStamp, forcingAPath, occurrence.jumpCount + 1, p),
					Scopes.addresses(defaultSpace.getAddress(this.eastNeighbour)))

				// If it is possible, then we do not try to find a path in other directions.
				return;
			}
			
			// If it is not possible, we will just go wherever we can (just like we would usually do) ...
		}
		
		// If we do not host the blank tile, we send the event PathCalculation to our neighbours ...
		// ... north one
		if (northNeighbour !== null && occurrence.provenanceDirection !== Direction.NORTH)
			emit(new PathCalculation(occurrence.requestId, occurrence.requestOrigin, Direction.SOUTH,
				occurrence.timeStamp, forcingAPath, occurrence.jumpCount + 1, p),
				Scopes.addresses(defaultSpace.getAddress(this.northNeighbour)))
		// ... east one
		if (eastNeighbour !== null && occurrence.provenanceDirection !== Direction.EAST)
			emit(new PathCalculation(occurrence.requestId, occurrence.requestOrigin, Direction.WEST,
				occurrence.timeStamp, forcingAPath, occurrence.jumpCount + 1, p),
				Scopes.addresses(defaultSpace.getAddress(this.eastNeighbour)))
		// ... south one
		if (southNeighbour !== null && occurrence.provenanceDirection !== Direction.SOUTH)
			emit(new PathCalculation(occurrence.requestId, occurrence.requestOrigin, Direction.NORTH,
				occurrence.timeStamp, forcingAPath, occurrence.jumpCount + 1, p),
				Scopes.addresses(defaultSpace.getAddress(this.southNeighbour)))
		// ... west one
		if (westNeighbour !== null && occurrence.provenanceDirection !== Direction.WEST)
			emit(new PathCalculation(occurrence.requestId, occurrence.requestOrigin, Direction.EAST,
				occurrence.timeStamp, forcingAPath, occurrence.jumpCount + 1, p),
				Scopes.addresses(defaultSpace.getAddress(this.westNeighbour)))
		
	}
	
	// Store the path that we received
	on PathFound {
		
		// If the path is a "good" path
		if (!occurrence.forcePath)
		{
			// We did not store any path yet
			if (bestPath === null)
			{
				bestPath = occurrence.path
				return
			}
			
			// If our stored path is longer than the new one we received
			if (bestPath.size > occurrence.path.size)
			{
				bestPath = occurrence.path
				return
			}
		}
		
		// If we do not have a "good" path yet, we bother considering a forced one (otherwise we don't)
		if (bestPath === null)
		{
			// We did not store any path yet
			if (bestForcedPath === null) {
				bestForcedPath = occurrence.path
				return
			}

			// If our stored path is longer than the new one we received
			if (bestForcedPath.size > occurrence.path.size) {
				bestForcedPath = occurrence.path
				return
			}
			
			// We could consider here, if bestForcedPath.size === occurrence.path.size
			// and compare the last frames of the path to avoid moving frames we just gave the token to
			// For now, we don't
		}
	}
	
	// Time is up to find new paths, we now use the best path we found
	on PathCalculationTimeOut {
		
		// DEBUGGING PATHFINDING
		info("DEBUGG : PathCalculationTimeOut")
		
		if (bestPath !== null)
		{
			info("DEBUGG : There is a good path (length : " + bestPath.size + ")")
			for (f : bestPath)
				info("DEBUGG : GOOD PATH > " + f.numFrame)
		}

		if (bestForcedPath !== null) {
			info("DEBUGG : There is a bad path (length : " + bestForcedPath.size + ")")
			for (f : bestForcedPath)
				info("DEBUGG : BAD PATH > " + f.numFrame)
		}
		
		// DEBUGG
		/*emit(new TokenReleased())
		if (true)
			return;*/
		
		// We have a good clean path
		if (bestPath !== null)
		{
			iterateMovementChain(bestPath)
		}
		// We have a path that will move some happy tiles on the way 
		else if (bestForcedPath !== null)
		{
			iterateMovementChain(bestForcedPath)
		}
		// We have nothing. We will try releasing the token hopping this solves something
		else
		{
			error("Error 03 : No path found in time at the end of PathCalculation spreading.")
			emit (new TokenReleased)
		}
	}
	
	def iterateMovementChain (path : ArrayList<FrameAgent>) {
		
		// Setting counter to know when we can release token
		nbAck = path.size + 1 // Waiting for an answer from each frame of the list + myself
		
		Collections.reverse(path);

		/*for (p : path)
		{
			info("PAAAATH : " + p.hostedNumTile)
		}*/


		// List to send to UpdateGUI
		var gui : ArrayList<FrameAgent>
		gui = new ArrayList<FrameAgent>
		gui.addAll(path)
		//info("EHAEUIAHEAIO : " + gui.get(0).hostedNumTile)
		gui.remove(0)

		emit(new UpdateGUI(gui, this.hostedNumTile))
		
		in (2000) [iterateMovementChain2(path)]
		
	}
	
	def iterateMovementChain2 (path : ArrayList<FrameAgent>) {
		var tempID : UUID

		// While there are more than two elements, we have to swap informations
		while (path.size >= 2) {
			// Swapping hosted Tile UUID
			tempID = path.get(0).hostedTile
			path.get(0).hostedTile = path.get(1).hostedTile
			path.get(1).hostedTile = tempID

			// info("DEBUGG : iterateMovementChain id " + path.get(0).hostedTile)
			
			// Tells the frame to send its info to its new Hosted Tile & to wait for the info from the Tile afterwards
			emit(new UpdateProblemInformations(true, this.ID),
				Scopes.addresses(defaultSpace.getAddress(path.get(0).ID)))

			// We remove the first element of the list
			path.remove(0)
		}

		// Swapping hosted Tile UUID with original aggressor
		tempID = path.get(0).hostedTile
		path.get(0).hostedTile = this.hostedTile
		this.hostedTile = tempID

		emit(new UpdateProblemInformations(true, this.ID), Scopes.addresses(defaultSpace.getAddress(path.get(0).ID)))
		wake(new UpdateProblemInformations(true, this.ID))
	}
	
	// Has to send informations to its tile
	on UpdateProblemInformations [start] {

		//info("DEBUGG : UpdateProblemInformations : sending data to " + hostedTile)
		emit(new UpdateProblemInformations(idNum, this.ID, occurrence.sendAckTo), Scopes.addresses(defaultSpace.getAddress(hostedTile)))
	}
	
	// Has to update informations from its tile & tell initiator it is done
	on UpdateProblemInformations [!start] {
		
		hostedNumTile = occurrence.num
		
		if (hostedNumTile === idNum)
			isSatisfied = true
		else
			isSatisfied = false

		//info("DEBUGG : UpdateProblemInformations [END, SENDING ACK]")
		
		emit(new AcknowledgmentDataUpdated(), Scopes.addresses(defaultSpace.getAddress(occurrence.sendAckTo)))
	}
	
	on AcknowledgmentDataUpdated {
		nbAck--
		
		//info("DEBUGG : AcknowledgmentDataUpdated : nbAck : " + nbAck)
		
		// We received all the acknowledgments we were waiting for
		if (nbAck === 0)
		{
			// Information helpful to avoid getting stuck around corners
			if (isSatisfied)
			{
				didMyTileMateHaveTheToken = true
			
				// If I am in a corner, I move the blank Tile around
				// TODO: todo
			}
			
			emit(new TokenReleased())
		}
	}
	
	def getXRow : int{
		return this.xRow
	}

	def getYCol : int {
		return this.yCol
	}

	def getCoordPair : CoordPair {
		return this.coordPair
	}
	
	def getIsSatisfied : boolean{
		return this.isSatisfied
	}

	def setIsSatisfied(b : boolean) {
		this.isSatisfied = b
	}

	def getIsBlocked : boolean {
		return this.isBlocked
	}

	def setIsBlocked(b : boolean) {
		this.isBlocked = b
	}

 	def getCostG() : int{
		return costG;
	}
	
	def setCostG(costG : int) {
			this.costG = costG;
	}

	def getCostH() : int{
			return costH;
	}

	def setCostH(costH : int) {
			this.costH = costH;
	}

	def getCostF() : int {
			return costF;
	}

	def setCostF(costF : int) {
			this.costF = costF;
	}

	def getUuidPreviousFrame() : UUID {
			return uuidPreviousFrame;
	}

	def setUuidPreviousFrame(uuidPreviousFrame : UUID) {
			this.uuidPreviousFrame = uuidPreviousFrame;
	}
 
	def getCoordsXYPreviousFrame() : CoordPair {
			return coordsXYPreviousFrame;
	}

	def setCoordsXYPreviousFrame(coordsXYPreviousFrame : CoordPair) {
			this.coordsXYPreviousFrame = coordsXYPreviousFrame;
	}
	
	def getCostsGHF : String{
		return "costG="+this.costG+" /costH="+this.costH+" /costF="+this.costF
	}
	
	def getIdNum : int {
		return this.idNum
	}
	
	def getNumFrame : int {
		this.idNum
	}
	
	def setNorthNeighbour(id : UUID) {
		northNeighbour = id
		nbNeighbours++
	}

	def setEastNeighbour(id : UUID) {
		eastNeighbour = id
		nbNeighbours++
	}

	def setSouthNeighbour(id : UUID) {
		southNeighbour = id
		nbNeighbours++
	}

	def setWestNeighbour(id : UUID) {
		westNeighbour = id
		nbNeighbours++
	}

	def getNbNeighbours : int{
		return this.nbNeighbours
	}

	def getNorthNeighbour : UUID {
		return this.northNeighbour
	}
	
	def getEastNeighbour : UUID {
		return this.eastNeighbour
	}
	
	def getSouthNeighbour : UUID {
		return this.southNeighbour
	}
	
	def getWestNeighbour : UUID {
			return this.westNeighbour
	}

	def setHostedTile(id : UUID) { 
		hostedTile = id
	}
	
	def getHostedTile : UUID {
		return this.hostedTile
	}

	def setHostedNumTile(num : int) {
		hostedNumTile = num
	}

	def getHostedNumTile : int {
		return this.hostedNumTile
	}

	on EndAgent {
		killMe
	}
	
}
