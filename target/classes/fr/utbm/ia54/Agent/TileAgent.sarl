
package fr.utbm.ia54.Agent

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import fr.utbm.ia54.Event.TileSet
import io.sarl.core.DefaultContextInteractions
import fr.utbm.ia54.Event.TokenReceived
import fr.utbm.ia54.Event.Assault
import fr.utbm.ia54.Event.TokenReleased
import io.sarl.util.Scopes
import java.util.UUID
import fr.utbm.taquin.events.ActionUI
import fr.utbm.ia54.Event.AskNeighbourSatisfaction
import fr.utbm.ia54.Event.ResponseNeighbourSatisfaction
import java.util.Map
import io.sarl.core.Behaviors
import io.sarl.core.Schedules

agent TileAgent {
	uses Logging, DefaultContextInteractions, Behaviors, Schedules

	var pleased = false // at right place or no (though kind of redundant with bool pleasant on frameAgent (could be useless)) 
	var angry = false // currently assaulting someone or not
	var numTile : int
	var numTileFromZero : int
	var numFrameHost : int //from 1
	var numFrameHostFromZero : int
	var uuidFrameHost : UUID
	var problemSize : int
	var tokenPriority : int
 
	var parentAgent : UUID
	
	on Initialize {

		if (this.class === null)
			return;
 
		parentAgent = occurrence.spawner

		numTile = occurrence.parameters.get(0) as Integer
		numTileFromZero = numTile - 1
  
		uuidFrameHost = occurrence.parameters.get(1) as UUID
		numFrameHostFromZero = occurrence.parameters.get(2) as Integer
		problemSize = occurrence.parameters.get(3) as Integer
		
		numFrameHost = numFrameHostFromZero + 1

		// Setting tokenPriority consulted by the scheduler
		tokenPriority = Math.min((numTile-1) / problemSize, (numTile-1) % problemSize)

		loggingName = 'TileAgent' + numTile // num to change
		
		if (numTileFromZero === numFrameHostFromZero)
		{
			pleased = true
		}
		 
		emit(new TileSet(this,null)) 
		
		// info("DEBUGG : Agent is set up.")
	}
	
	on TokenReceived {
		
		info("I received the token.")
		
		if (pleased) {
			emit(new TokenReleased())
		
		} else { 
  
//			info("JE VAIS CHANGER COULEUR : je suis "+ID)
			emit(new ActionUI("red", numTile), Scopes.addresses(defaultSpace.getAddress(parentAgent)))

			// We have to choose a target
			// Boolean useless (only here for compilation purpose)
			var b = chooseTarget
			
		}
		
   
   		// old comments : [
   
		// si (mon_etat = agressé)
		// j'agresse un voisin pour fuir
		
			// sinon si (mon_humeur = satisfait)
		// je transmet le token gratuitement à quelqu'un sans l'agresser
		
			// sinon si (mon_humeur = non_satisfait)
		// j'agresse un voisin pour accroitre ma satisfaction]
		
	}
	  
	def chooseTarget : boolean {

		//info("DEBUGG : choose target")

		// If I am on the same line or column as my desired spot, I just go in the spot direction
		
		// I am at the right longitude, therefore I will assault north or south
		if (numFrameHostFromZero % problemSize === numTileFromZero % problemSize)
			if (numTileFromZero < numFrameHostFromZero)
				emit(new Assault(Position.NORTH, false), Scopes.identifiers(uuidFrameHost))
			else
				emit(new Assault(Position.SOUTH, false), Scopes.identifiers(uuidFrameHost))
		
		// I am at the right latitude, therefore I will assault east or west
		else if (numFrameHostFromZero / problemSize === numTileFromZero / problemSize)
			if (numTileFromZero < numFrameHostFromZero)
				emit(new Assault(Position.WEST, false), Scopes.identifiers(uuidFrameHost))
			else
				emit(new Assault(Position.EAST, false), Scopes.identifiers(uuidFrameHost))
		 
		// If I am not on the same line or column as my desired spot, I can choose between the two directions that will bring me closer
		else {

			//info("DEBUGG : choose target between two targets")
			
			// Finding out these two possible directions :
			
			// Looking up if I am to the north or to the south of my target frame
			var north = (numFrameHostFromZero / problemSize >= numTileFromZero / problemSize)
	
			// Looking up if I am to the west or to the east of my target frame
			var west = (numFrameHostFromZero % problemSize >= numTileFromZero % problemSize)
			
		 	// I have to choose between two targets, I ask my frame to get more informations
			emit(new AskNeighbourSatisfaction(north, west), Scopes.identifiers(uuidFrameHost))
			
		} 

		// If void function, code does not compile...
		return true
	}
	 
	// We had to ask for more informations to choose who to target
	on ResponseNeighbourSatisfaction {

		//info("DEBUGG : Assault one of the neighbour that responded")
		
		// The map has only two entries
		// We get first entry of the map
		var iter = occurrence.neighbourSatisfaction.entrySet().iterator()
		var entry = iter.next()

		// If this neighbour is unhappy, therefore we can target him
		if (entry.value === false)
		{
			//info ("DEBUGG : Assault first neighbour which responded")
			emit(new Assault(entry.key, false), Scopes.identifiers(uuidFrameHost))
		}
		// Wether or not the second neighbour is happy, we have to target someone anyway
		else {
			//info("DEBUGG : Assault second neighbour which responded")
			entry = iter.next()
			emit(new Assault(entry.key, false), Scopes.identifiers(uuidFrameHost))
		}
	}
	
	on Assault {
	}

	def getNumFrameHost : int{
		return this.numFrameHost
	}
	
	def setNumFrameHost(num : int){
		this.numFrameHost = num
	}

	def getNumFrameHostFromZero : int {
		return this.numFrameHostFromZero
	} 

	def setNumFrameHostFromZero(num : int) {
		this.numFrameHostFromZero = num
	}
	
	def getUuidFrameHost : UUID{
		return this.uuidFrameHost
	}
	
	def setUuidFrameHost(uuid : UUID){
		this.uuidFrameHost = uuid
	}
	
	def getTokenPriority : int {
		this.tokenPriority
	}

	def getNumTile : int {
		this.numTile
	}

	def getIsHappy : boolean {
		this.pleased
	} 
	
	def setIsHappy(happy : boolean){
		this.isHappy = happy
	}
	 
	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.") 
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}
}
