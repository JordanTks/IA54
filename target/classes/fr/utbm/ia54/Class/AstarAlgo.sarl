/** 
 * 
 */
package fr.utbm.ia54.Class

import java.util.ArrayList
import fr.utbm.ia54.Agent.FrameAgent
import java.util.UUID
import fr.utbm.ia54.Agent.TileAgent
import fr.utbm.ia54.gui.TaquinFxViewerController

public class AstarAlgo {

	var PROBLEM_SIZE = 3
	var nbFrameSet = 0
	var nbTileSet = 0
	var frameList = new ArrayList<FrameAgent>()

	// TKS
	var frameUUIDList = new ArrayList<UUID>()
	var listCoordPairsOfFrames = new ArrayList<CoordPair>()

	var openListOfFrames = new ArrayList<InfosFrame>()
	var closedListOfFrames = new ArrayList<InfosFrame>()

	// infos of the frame on which there is the Tile with the Token
	var beginningFrame : FrameAgent
	var beginningInfosFrame : InfosFrame
	var uuidFRAMEwithTokenTile : UUID
	var coordsFRAMEwithTokenTile : CoordPair

	// infos of the frale on which there is the BlankTile
	var arrivalFrame : FrameAgent
	var arrivalInfosFrame : InfosFrame
	var uuidFRAMEwithBlankTile : UUID
	var coordsFRAMEwithBlankTile : CoordPair

	var tileList = new ArrayList<TileAgent>()
	var tokenPriorityList = new ArrayList<ArrayList<TileAgent>>()

	var ctrl : TaquinFxViewerController
	
	
//	
//	
//		/** 
//		 * calculate the euclidean distance between 2 frames
//		 * @params a,b : 2 FrameAgent
//		 * @return int: square euclidean distance
//		 */
//	 // TKS
//	def distEuclidian(a : FrameAgent, b : FrameAgent) : int {
//		return ((a.XRow - b.XRow) * (a.XRow - b.XRow) + (a.YCol - b.YCol) * (a.YCol - b.YCol))
//	}
//	
//	/** 
//	 * determinate if the frame is in the list
//	 * @params pair, listOfFrames : CoordPair & ArrayList<InfosFrame>
//	 * @return boolean: true if the CoordPair correspond to coords of an FrameAgent in the list
//	 */
//	 // TKS
//	def isInFrameList(pair : CoordPair, listOfFrames : ArrayList<InfosFrame>) : boolean {
//		for (fa : listOfFrames) {
//			if (pair.equals(fa.coordsCurrentFrame))
//				return true
//		}
//		return false
//	}
//	
//	/** 
//	 * add the neighbour's frames of the current frame
//	 * @params currentFrame: the current FrameAgent
//	 */
//	 // TKS
//	def addNeighbourFrames(currentFrame : FrameAgent) {					
//		// the north's frame exists======================================================================================================================
//		if (currentFrame.northNeighbour != null) {
//			var index = frameUUIDList.indexOf(currentFrame.northNeighbour)
//
//			// TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
//			if (!frameList.get(index).isSatisfied) {
//
//				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var coordNeighbour = frameList.get(index).coordPair
//				// if doesn't exist in the closed list
//				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {
//
//					// the treated frame (stock the infos)
//					var infosFrame = new InfosFrame(currentFrame.northNeighbour, coordNeighbour)
//
//					// costG of north's neighbour: cost of previous + distance to previous
//					var indexForClosedList = -1
//					for (iterator : closedListOfFrames) {
//						indexForClosedList++
//						if (iterator.uuidCurrentFrame == currentFrame.ID)
//							break
//					}
//
//					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
//						distEuclidian(frameList.get(index), currentFrame)
//
//					// costH of north's neighbour: it to arrival
//					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
//					infosFrame.costF = infosFrame.costG + infosFrame.costH
//
//					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
//					infosFrame.uuidPreviousFrame = currentFrame.ID
//					infosFrame.coordsPreviousFrame = currentFrame.coordPair
//
//					var indexForOpenList = -1
//					for (iterator : openListOfFrames) {
//						indexForOpenList++
//						if (iterator.uuidCurrentFrame == currentFrame.northNeighbour)
//							break
//					}
//
//					// if already exists: compare the cost
//					if (isInFrameList(coordNeighbour, openListOfFrames)) {
//						// only if the new path is shorter: update it ELSE do nothing
//						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF)
//							openListOfFrames.set(indexForOpenList, infosFrame)
//
//					} // the treated frame (north's frame) is not in the openList yet: add it
//					else {
//						openListOfFrames.add(infosFrame)
//					}
//				}
//			}
//		}
//
//		// the south's frame exists======================================================================================================================
//		if (currentFrame.southNeighbour != null) {
//			var index = frameUUIDList.indexOf(currentFrame.southNeighbour)
//
//			// TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
//			if (!frameList.get(index).isSatisfied) {
//
//				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var coordNeighbour = frameList.get(index).coordPair
//				// if doesn't exist in the closed list
//				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {
//
//					// the treated frame (stock the infos)
//					var infosFrame = new InfosFrame(currentFrame.southNeighbour, coordNeighbour)
//
//					// costG of south's neighbour: cost of previous + distance to previous
//					var indexForClosedList = -1
//					for (iterator : closedListOfFrames) {
//						indexForClosedList++
//						if (iterator.uuidCurrentFrame == currentFrame.ID)
//							break
//					}
//
//					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
//						distEuclidian(frameList.get(index), currentFrame)
//
//					// costH of south's neighbour: it to arrival
//					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
//					infosFrame.costF = infosFrame.costG + infosFrame.costH
//
//					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
//					infosFrame.uuidPreviousFrame = currentFrame.ID
//					infosFrame.coordsPreviousFrame = currentFrame.coordPair
//
//					var indexForOpenList = -1
//					for (iterator : openListOfFrames) {
//						indexForOpenList++
//						if (iterator.uuidCurrentFrame == currentFrame.southNeighbour)
//							break
//					}
//
//					// if already exists: compare the cost
//					if (isInFrameList(coordNeighbour, openListOfFrames)) {
//						// only if the new path is shorter: update it ELSE do nothing
//						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF)
//							openListOfFrames.set(indexForOpenList, infosFrame)
//
//					} // the treated frame (south's frame) is not in the openList yet: add it
//					else {
//						openListOfFrames.add(infosFrame)
//					}
//				}
//			}
//		}
//
//		// the east's frame exists======================================================================================================================
//		if (currentFrame.eastNeighbour != null) {
//			var index = frameUUIDList.indexOf(currentFrame.eastNeighbour)
//
//			// TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
//			if (!frameList.get(index).isSatisfied) {
//
//				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var coordNeighbour = frameList.get(index).coordPair
//				// if doesn't exist in the closed list
//				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {
//
//					// the treated frame (stock the infos)
//					var infosFrame = new InfosFrame(currentFrame.eastNeighbour, coordNeighbour)
//
//					// costG of east's neighbour: cost of previous + distance to previous
//					var indexForClosedList = -1
//					for (iterator : closedListOfFrames) {
//						indexForClosedList++
//						if (iterator.uuidCurrentFrame == currentFrame.ID)
//							break
//					}
//
//					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
//						distEuclidian(frameList.get(index), currentFrame)
//
//					// costH of east's neighbour: it to arrival
//					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
//					infosFrame.costF = infosFrame.costG + infosFrame.costH
//
//					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
//					infosFrame.uuidPreviousFrame = currentFrame.ID
//					infosFrame.coordsPreviousFrame = currentFrame.coordPair
//
//					var indexForOpenList = -1
//					for (iterator : openListOfFrames) {
//						indexForOpenList++
//						if (iterator.uuidCurrentFrame == currentFrame.eastNeighbour)
//							break
//					}
//
//					// if already exists: compare the cost
//					if (isInFrameList(coordNeighbour, openListOfFrames)) {
//						// only if the new path is shorter: update it ELSE do nothing
//						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF)
//							openListOfFrames.set(indexForOpenList, infosFrame)
//
//					} // the treated frame (east's frame) is not in the openList yet: add it
//					else {
//						openListOfFrames.add(infosFrame)
//					}
//				}
//			}
//		}
//
//		// the west's frame exists======================================================================================================================
//		if (currentFrame.westNeighbour != null) {
//			var index = frameUUIDList.indexOf(currentFrame.westNeighbour)
//
//			// TODO: ne rien faire si elle est satisfaite (ou bloquée ?)
//			if (!frameList.get(index).isSatisfied) {
//
//				var coordNeighbour = listCoordPairsOfFrames.get(index) // or: var coordNeighbour = frameList.get(index).coordPair
//				// if doesn't exist in the closed list
//				if (!isInFrameList(coordNeighbour, closedListOfFrames)) {
//
//					// the treated frame (stock the infos)
//					var infosFrame = new InfosFrame(currentFrame.westNeighbour, coordNeighbour)
//
//					// costG of west's neighbour: cost of previous + distance to previous
//					var indexForClosedList = -1
//					for (iterator : closedListOfFrames) {
//						indexForClosedList++
//						if (iterator.uuidCurrentFrame == currentFrame.ID)
//							break
//					}
//
//					infosFrame.costG = closedListOfFrames.get(indexForClosedList).costG +
//						distEuclidian(frameList.get(index), currentFrame)
//
//					// costH of west's neighbour: it to arrival
//					infosFrame.costH = distEuclidian(frameList.get(index), arrivalFrame)
//					infosFrame.costF = infosFrame.costG + infosFrame.costH
//
//					// previousFrame = the previousFrame in the chain of aggression (to build the path in the opposite direction)
//					infosFrame.uuidPreviousFrame = currentFrame.ID
//					infosFrame.coordsPreviousFrame = currentFrame.coordPair
//
//					var indexForOpenList = -1
//					for (iterator : openListOfFrames) {
//						indexForOpenList++
//						if (iterator.uuidCurrentFrame == currentFrame.westNeighbour)
//							break
//					}
//
//					// if already exists: compare the cost
//					if (isInFrameList(coordNeighbour, openListOfFrames)) {
//						// only if the new path is shorter: update it ELSE do nothing
//						if (infosFrame.costF < openListOfFrames.get(indexForOpenList).costF)
//							openListOfFrames.set(indexForOpenList, infosFrame)
//
//					} // the treated frame (west's frame) is not in the openList yet: add it
//					else {
//						openListOfFrames.add(infosFrame)
//					}
//				}
//			}
//		}
//	} // end of addNeighbourFrames()
//	/** 
//	 * get the frame with best cost from the frameList
//	 * @param listFrames: list of InfosFrame
//	 * @return InfosFrame: the infosFrame with the best (lower) cost OR null if the list is empty
//	 */
//	// TKS
//	def getBestFrame(listFrames : ArrayList<InfosFrame>) : InfosFrame {
//		if (!listFrames.empty) { // the list is not empty
//			var costF = listFrames.get(0).costF
//			var infoFrame = listFrames.get(0)
//
//			for (frame : listFrames) {
//				if (frame.costF < costF) { // get the lower cost in the list
//					costF = frame.costF
//					infoFrame = frame
//				}
//			}
//			return infoFrame
//		}
//
//		return null
//	}
//	/** 
//	 * add the InfosFrame in the closedList and remove it from the openList
//	 * @param coords: CoordPair of the frame to manipulate
//	 */
//	// TKS
//	def addInClosedList(coords : CoordPair) {
//		var index = -1
//		for (ite : openListOfFrames) {
//			index++
//			if (ite.coordsCurrentFrame.equals(coords)) { // found it in the openList
//				closedListOfFrames.add(ite) // add in the closedList
//				break
//			}				
//		}
//		openListOfFrames.remove(index) 	// remove it from the openList
//	}
//	/** 
//	 * get the chain of aggression in a list of InfosFrame
//	 * return ArrayList<InfosFrame>: the list of InfosFrame for the aggression in the right order
//	 */
//	// TKS
//	def buildChainAggression(beginningFrame : InfosFrame) : ArrayList<InfosFrame> {
//		var chain = new ArrayList<InfosFrame>
//		var index = closedListOfFrames.size - 1
//		var tmpFrame : InfosFrame
//		var prevFrame : InfosFrame
//		var flagEnd = false
//
//		// the last one is the arrivalFrame
//		tmpFrame = closedListOfFrames.get(index)
//		chain.add(tmpFrame)
//
//		// get the previousFrame of the first one
//		prevFrame = new InfosFrame(tmpFrame.uuidPreviousFrame, tmpFrame.coordsPreviousFrame)
//
//		// loop with each previousFrame of the currentFrame treated
//		while (!prevFrame.equals(beginningFrame)) {
//			chain.add(prevFrame)
//
//			var i = -1
//			for (ite : closedListOfFrames) {
//
//				// the end
//				if (tmpFrame.coordsPreviousFrame == null) {
//					flagEnd = true
//					break
//				}
//					
//				i++
//				if (ite.coordsCurrentFrame.equals(tmpFrame.coordsPreviousFrame))
//					break
//			}
//
//			// looping on the closedList
//			if (!flagEnd) {
//				tmpFrame = closedListOfFrames.get(i)
//				prevFrame = new InfosFrame(closedListOfFrames.get(i).uuidCurrentFrame,
//					closedListOfFrames.get(i).coordsCurrentFrame)
//			} // the end of the loop
//			else
//				break
//		}
//
//		return chain
//	}
//	/** 
//	 * execute the A-star algorithm
//	 */
//	// TKS
//	def findPath {
//
//		// val beginningFrameTMP = new InfosFrame(frameUUIDList.get(0), listCoordPairsOfFrames.get(0)) // TODO: CHANGE WITH THE FRAME ON WHICH THE FILE HAS THE TOKEN
//		// val arrivalFrame = new InfosFrame(frameUUIDList.get((PROBLEM_SIZE * PROBLEM_SIZE) - 1),listCoordPairsOfFrames.get((PROBLEM_SIZE * PROBLEM_SIZE) - 1))
//		var currentFrame = beginningInfosFrame
//
//		openListOfFrames.add(beginningInfosFrame)
//		addInClosedList(beginningInfosFrame.coordsCurrentFrame)
//
//		// get the frame with the index of FrameList
//		var indexOfFrameList = -1
//		for (ite : frameList) {
//			indexOfFrameList++
//			if (ite.coordPair.equals(beginningInfosFrame.coordsCurrentFrame))
//				break
//		}
//
//		// add the neighbours in the openList
//		addNeighbourFrames(frameList.get(indexOfFrameList))
//		
//		// until the destination has been reached && openList is empty
//		while (!currentFrame.coordsCurrentFrame.equals(arrivalInfosFrame.coordsCurrentFrame) && !openListOfFrames.
//				empty) {
//					currentFrame = getBestFrame(openListOfFrames)
//					addInClosedList(currentFrame.coordsCurrentFrame)
//
//					var indexOfFrameList2 = -1
//					for (ite : frameList) {
//						indexOfFrameList2++
//						if (ite.coordPair.equals(currentFrame.coordsCurrentFrame))
//							break
//					}
//					addNeighbourFrames(frameList.get(indexOfFrameList2))
//				}
//
//				// if destination is reached : build the path in the opposite direction of the chain of aggression
//		if (currentFrame.coordsCurrentFrame.equals(arrivalInfosFrame.coordsCurrentFrame)) {
//			info("- A-star : destination IS reached! -")
//		} else {
//			info("- A-star : destination IS NOT reached! -")
//		}
//
//		// sort in the opposite order AND remove duplicate frames
//		var tmpChainAggression = buildChainAggression(beginningInfosFrame)
//		var chainAggression = new ArrayList<InfosFrame>()
//		var tmpFrame = tmpChainAggression.get(tmpChainAggression.size - 1)
//		chainAggression.add(tmpFrame)
//		for (var i = tmpChainAggression.size - 2; i >= 0; i--) {
//			if (!(tmpFrame.uuidCurrentFrame === tmpChainAggression.get(i).uuidCurrentFrame)) {
//				tmpFrame = tmpChainAggression.get(i)
//				chainAggression.add(tmpFrame)
//			}
//		}
//
//		// YB
//		var listSwap : ArrayList<Integer> = new ArrayList()
//
//		info("---- Chain of aggression below ----")
//		for (var i = 0; i < chainAggression.size; i++) {
//
//			// Frame with the Tile which wants to move
//			if (chainAggression.get(i).coordsCurrentFrame.equals(beginningFrame.coordPair)) {
//
//				info("BeginningFrame= " + chainAggression.get(i).coordsCurrentFrame.toString)
//			} // colorize the chain of aggression (NOT the extremities)
//			else if (!chainAggression.get(i).coordsCurrentFrame.equals(arrivalFrame.coordPair)) {
//
//				info("Frame" + (i + 1) + "= " + chainAggression.get(i).coordsCurrentFrame.toString)
//				
//				for (var j = 0; j < frameList.size; j++) {
//					if (frameList.get(j).ID === chainAggression.get(i).uuidCurrentFrame) {
//
//						// YB
//						listSwap.add(frameList.get(j).hostedNumTile)
//
//						ctrl.setColor("blue", frameList.get(j).hostedNumTile)
//
//						// YB
//						Thread.sleep(1000)
//						
//						break
//					}
//				}
//			} else {
//				info("ArrivalFrame= " + chainAggression.get(i).coordsCurrentFrame.toString)
//			}
//		}
//		
//			// YB
//		// ctrl.swap(listSwap)
//	}

}
